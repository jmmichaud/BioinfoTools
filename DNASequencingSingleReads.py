#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 18 11:09:21 2018

@author: jennifermichaud
"""
import copy
import random
import numpy as np


class SingleReadDNASeqData(object):
    """Takes in DNA sequencing data as a list of capitilized DNA strings of 
    multiple lengths for the purpose of assembly into one or more contigs.
    """
    def __init__(self, rawreads):
        self.rawreads = rawreads
    
    def GetParams(self):
        """Determines number of reads, length of reads, and if .  If read length is uniform
        sets reads as kmers and k as the kmer lenght.  All of these parameters
        are then usuable by other functions.
        """
        self.readcount = len(self.rawreads)
        readlengthlist = [len(read) for read in self.rawreads]
        self.readlengthdict = {}
        for rlen in readlengthlist: #generate dictionary for how often a read lenth is repeated
            if rlen in self.readlengthdict:
                self.readlengthdict[rlen] += 1
            else:
                self.readlengthdict[rlen] = 1
        for key in self.readlengthdict:
            if len(self.readlengthdict) == 1:
                self.readlength = key
                self.uniform = "Y"
            else:
                self.readlength = "Variable"
                self.uniform = "N"
        if self.uniform == "Y":  #Room to ammend code to allow exceptions for non uniform read lengths
            self.kmers = self.rawreads
            self.k = self.readlength
        print("\nRead Data")
        print("===========================")
        print("Number of reads: " + str(self.readcount))
        print("Readlength is uniform?: " + self.uniform)
        print("Readlength: " + str(self.readlength))
        
        return self.readcount, self.readlength, self.uniform, self.readlengthdict, self.kmers, self.k
    
    def DeBruijn(self):
        """Inputs a collection of k-length kmers (patterns) as list of strings.
        Outputs the overlap graph in the form of an dictionary: 
        {left edge: [right edge1, right edge2...],...}. Adjacency is determined by the 
        overlap of a suffix(length k-1) of one pattern with a prefix(k-1) of another 
        pattern. Each pattern edge k-1 gets a node to assign overlaps for a resulting 
        k-2 overlaps between k-1 nodes. DeBruijn Graphs generate graphs of edges and 
        allow for the use of Eulerian paths (visit each edge once) which are easier 
        to solve than Hamiltonian paths (visit each vertex once).
        """
        try:
            self.kmers
        except NameError:
            self.GetParams()
        self.dbdict = {} #map of nodes to neighbors
        for kmer in self.kmers:  #generates nodes, kmers is generated by CheckReadParams()
            leftkmer, rightkmer = kmer[:-1], kmer[1:]
            if leftkmer not in self.dbdict:
                self.dbdict.setdefault(leftkmer, []).append(rightkmer) #adds edge to dictionary with a list as entry, appends right edge
            else:
                self.dbdict[leftkmer].append(rightkmer) #appends rightedge to node
        return self.dbdict

    
    def InOutDict(self):
        """Inputs a DeBruijn graph as a dictionary in the format:
        {left edge: [right edge1, right edge2...],...}.
        Ouputs the number in degree and out degree of all nodes in a DB graph
        as a dictionary in the format:{node1 : [#indegree, #outdegree]...}. 
        """
        try:
            self.dbdict
        except NameError:
            self.DeBruijn()
        self.inoutdict = {}
        for key in self.dbdict: 
            if key not in self.inoutdict: #add new dictionary entry
                self.inoutdict[key] = [0, 0]
                for item in self.dbdict[key]:
                    self.inoutdict[key][1] += 1 #add outdegrees
                    if item not in self.inoutdict: #add new dictionary entry
                        self.inoutdict[item] = [0, 0]
                        self.inoutdict[item][0] = 1 #add indegree
                    else:  #for existing entry
                        self.inoutdict[item][0] += 1 #add indegree
            else:  #for existing entry
                for item in self.dbdict[key]:
                    self.inoutdict[key][1] += 1  #add outdegrees
                    if item not in self.inoutdict: #add new dictionary entry
                        self.inoutdict[item] = [0, 0]
                        self.inoutdict[item][0] = 1 #add indegree
                    else: #for existing entry
                        self.inoutdict[item][0] += 1 #add indegree
        return self.inoutdict
    
    
    def StartEndNodes(self):
        """Inputs a dictionary that enumerates the number of indegrees and outdegrees
        for all nodes in a DeBruin Graph in the format: {node1 : [#indegree, #outdegree]...}.
        Outputs the starting node for a semi-balanced path. A semi-balanced path is a path
        where all nodes have the same number of indegrees as outdegrees except for 2
        nodes that signify the begining and end of the path.  Start node has one less 
        indegree and the end node has one less outdegree.
        Outputs two variables start node of a Eularian path as a string and a string
        value that indicates whether the path is balanced. 'B' means fully balanced 
        (circular), 'S' semi-balanced only two nodes that are unbalanced.
        """
        try:
            self.inoutdict
        except NameError:
            self.InOutDict()
        self.startnodes = []
        self.endnodes = []
        self.balanced = 'U' # 'BU' balanced(unbranched), 'BB' balanced(branched), 'SU' semi-balanced (unbranched), ''SB' semi-balanced (branched), 'U' unbalanced
        unbcount = 0
        degreemax = 'N'
        branched = 'N'
        for key in self.inoutdict:
            outminusmin = self.inoutdict[key][1] - self.inoutdict[key][0]
            if outminusmin == 1:
                self.startnodes.append(key)
                unbcount += 1
            elif outminusmin == -1:
                unbcount += 1
                self.endnodes.append(key)
            elif abs(outminusmin) >1:
                unbcount += abs(outminusmin) 
                degreemax = 'Y'
            elif outminusmin == 0:
                if self.inoutdict[key][1] + self.inoutdict[key][0] > 2:
                    branched = 'Y'     
        if unbcount == 0:
            if branched == 'Y':
                self.balanced = 'BB'
            else:
                self.balanced = 'BU'
        elif unbcount <= 2:
            if branched == 'Y':
                self.balanced = 'SB'
            else:
                self.balanced = 'SU'
        elif degreemax == 'Y':
            self.balanced = 'U'
        return self.startnodes, self.endnodes, self.balanced

    
    def EulerianCycle(self):
        """Inputs a DeBruijn graph as a dictionary in the format:
        {left edge: [right edge1, right edge2...],...}.
        Outputs a Eulerian cycle that visits each edge once using DB Graph for
        unbranched balanced and semibalanced DeBruijn Graphs as a list of 
        ordered edges. 
        """
        try:
            self.dbdict
            self.inoutdict
            self.startnodes
            self.balanced
        except NameError:
            self.StartEndNodes()
        dict2 = copy.deepcopy(self.dbdict)
        self.eulpath = []
        temppath = []
        startposition = self.startnodes[0]
        if self.balanced == 'BU':    
            startposition = random.choice(list(dict2))
        elif self.balanced == 'U':
            raise Exception('The DeBruijn Graph indicates an unbalanced path. Program terminated.')
        curredge = startposition   
        while dict2 != {}:  #deletes edges from dictionary as they are used
            if curredge in dict2: #if leftedge in dictionary, looks up entry
                self.eulpath.append(curredge)
                randpos = np.random.randint(0,len(dict2[curredge])) #choose random rightedge if more than one
                position = dict2[curredge][randpos]
                dict2[curredge].remove(dict2[curredge][randpos]) #remove edge from dictionary
                if dict2[curredge] == []: #delete left edge (key) if no right edges remain
                    del dict2[curredge]
                curredge = position #set position to new left edge
            elif self.eulpath != []: #if edges still exist and eulpath not empty, add edge to temp list and remove from eulpath
                temppath.append(curredge) #adds dead end location to temppath
                curredge = self.eulpath.pop(-1) #remove last location from eulerian path and set to current location
        self.eulpath.append(curredge)
        while temppath != []:
            self.eulpath.append(temppath.pop(-1))
        return self.eulpath #outputs the list of  ordered kmer strings and the balanced parameter

    def GenomePathReconstruction(self):
        """Inputs a sequence of k-mers Pattern(1), … ,Pattern(n) such that the last k - 1 
        symbols of Patterni are equal to the first k-1 symbolsb of Patterni+1 for 1 ≤ i ≤ n-1.
        outputs a string Text of length k+n-1 such that the i-th k-mer in Text is 
        equal to Patterni  (for 1 ≤ i ≤ n)"""
        try:
            self.eulpath
            self.balanced
        except NameError:
            self.EulerianCycle()
        sequence = []
        sequence.append(self.eulpath[0])
        km = len(self.eulpath[0])
        for i in range(1,len(self.eulpath)):
            sequence.append(self.eulpath[i][-1])
        self.assembled = ''.join(sequence)
        if self.balanced == 'BU':
            self.assembled = self.assembled[:-km]
        return self.assembled
    
    
    def AssemblyNonBranchingContigs(self):
        """ Inputs a DeBruijn graph as a dictionary in the format:
        {left edge: [right edge1, right edge2...],...}, a dictionary that enumerates 
        the number of indegrees and outdegrees for all nodes in a DeBruin Graph in 
        the format: {node1 : [#indegree, #outdegree]...} and the output of the function
        StartEndNodes() that contains a list of start nodes. Takes unbalanced graphs
        and generates the longest contigs that can be assembled as nonbranching 
        contigs. Generally uses look up of next nodes and if balanced (1 indegree, 
        1 out) adds to the contig.  End or branched nodes (exists as greater than 
        1 in- and out- degrees) terminate contigs and if a branched node new contigs
        are started.  Avoids assembly of contigs that have more than one possible
        order.
        Output is a list of non branching contigs that include potenial overlaps 
        between contigs of k-1 and a numpy array of contigs that serves as a 
        mini-scaffold demonstrating the overlaps between contigs. Each row in the 
        array represents a branched contig, the columns [0,...n] order the contigs 
        from beginning to end each as a list where adjacent columns represent adjacent 
        contigs. Branched contigs where multiple possibilities exist are listed in 
        the same list/column.  For example, the array [[ABCDE], [CDEFGHI, CDEQPRGHI], 
        [GHIJKLM]] represents two possible contigs: 'ABCDEFGHIJKLM' and
        'ABCDEQPRGHIJKLM'. [[list(['CAAATGCAT']), list(['CATACGCTCA', 'CATCA']), 
        list(['TCACCCAG', 'TCAT'])]]. For more complex branching columns may not
        always represent adjacent contigs.   
        """
        try:
            self.dbdict
            self.inoutdict
            self.startnodes
            self.balanced
        except NameError:
            self.StartEndNodes()
        self.contiglist = []
        lastedges = []
        remainingpaths = copy.deepcopy(self.dbdict)  #duplicated of dbdict and inout dict are made so nodes can be deleted as used in contigs.
        remainingdegrees = copy.deepcopy(self.inoutdict)
        numofrows = len(self.startnodes)
        numofcolumns = 1
        for key in self.inoutdict: #create an array as large as potential contig fragments, a column allotted for every
            if self.inoutdict[key][1] > 1:
                numofcolumns += 1
        self.contigarray = np.empty((numofrows, numofcolumns), dtype = object)
        for x in range(numofrows):
            for y in range(numofcolumns):
                self.contigarray[x,y] = []
        starts = copy.deepcopy(self.startnodes)
        i = 0
        j=0
        node = random.choice(starts)  #initalize a temp path list with a start node
        starts.remove(node) #remove start node from list
        nonbranchingpaths = []
        nonbranchingpaths.append(node)
        while remainingpaths != {}:
            if node in remainingpaths: #if an internal node already used skips it
                nextnode = random.choice(remainingpaths[node]) #add next node by random choice if muliple outgoing nodes exist
                remainingpaths[node].remove(nextnode) #remove selected outgoing node from db graph list
                remainingdegrees[node][1] -= 1
                if remainingdegrees[node][0] !=0: #if not a start node subtracts 1 from indegrees
                    remainingdegrees[node][0] -= 1 
                if remainingdegrees[node][0] == 0 and remainingdegrees[node][1] == 0: #if no remaining in- or out- degrees delete nodes
                    del remainingpaths[node] 
                    del remainingdegrees[node]
                node = str(nextnode)
                nonbranchingpaths.append(node[-1])                              
                while remainingdegrees[node][1] ==1 and remainingdegrees[node][0]== 1: #while encountering edges with 1 in- and 1 out- degree           
                    nextnode = random.choice(remainingpaths[node])
                    remainingpaths[node].remove(nextnode)
                    remainingdegrees[node][1] -= 1
                    if remainingdegrees[node][0] !=0: #if not a start node subtracts 1 from indegrees
                        remainingdegrees[node][0] -= 1 
                    if remainingdegrees[node][0] == 0 and remainingdegrees[node][1] == 0: #if no remaining in- or out- degrees  delete nodes
                        del remainingpaths[node] 
                        del remainingdegrees[node]           
                    node = str(nextnode)
                    nonbranchingpaths.append(node[-1])
            if node not in lastedges and node in remainingpaths:
                if remainingdegrees[node][1] !=0: 
                    lastedges.append(node) #keep last edges to start next contig
                elif remainingdegrees[node][1] == 0: #delete end node once reached
                    del remainingdegrees[node]
            if lastedges != []:        
                node = lastedges[0] #usefirst entry in list
            self.contiglist.append(''.join(nonbranchingpaths))
            self.contigarray[i,j].append(''.join(nonbranchingpaths))
            try:  #initializes the previous last choice variable without overwriting if it already exists
                prevlast
            except NameError:
                prevlast = ""
            if remainingdegrees[node][1] > 0: #if there are outdegree for the node make a new contig with it as the start
                if prevlast != node:
                    j += 1
                nonbranchingpaths = []
                nonbranchingpaths.append(node)
                nextnode = random.choice(remainingpaths[node])
                remainingpaths[node].remove(nextnode)
                remainingdegrees[node][1] -= 1
                if remainingdegrees[node][0] !=0: #if not a start node subtracts 1 from indegrees
                    remainingdegrees[node][0] -= 1 
                if remainingdegrees[node][0] == 0 and remainingdegrees[node][1] == 0: #if no remaining in- or out- degrees degrees delete nodes
                    del remainingpaths[node] 
                    del remainingdegrees[node]
                    lastedges.remove(node)
                prevlast = str(node) #needed only for making numpy map
                node = str(nextnode)
                nonbranchingpaths.append(node[-1])
            elif remainingdegrees[node][1] == 0: #if endnode is reached
                if remainingdegrees[node][0] == 1: #remove endnode 
                    del remainingdegrees[node]
                if starts != []: #start new contig with a new start node
                    i += 1
                    j = 0
                    node = random.choice(starts)
                    starts.remove(node)
                    nonbranchingpaths = []
                    nonbranchingpaths.append(node)
                    nextnode = random.choice(remainingpaths[node])
                    remainingpaths[node].remove(nextnode)
                    remainingdegrees[node][1] -= 1
                    if remainingdegrees[node][0] !=0: #if not a start node subtracts 1 from indegrees
                        remainingdegrees[node][0] -= 1 
                    if remainingdegrees[node][0] == 0 and remainingdegrees[node][1] == 0: #if no remaining in- or out- degrees
                        del remainingpaths[node] #remove
                        del remainingdegrees[node]
                    node = str(nextnode)
                    nonbranchingpaths.append(node[-1])
            contig = ''.join(nonbranchingpaths)        
            if remainingpaths == {} and contig not in self.contiglist:  #adds last fragment to list
                self.contiglist.append(contig)
                self.contigarray[i,j].append(contig)
        return self.contiglist, self.contigarray
    
    

##### TEST DATA ###################################
     

#input_dna = """GAGG
#CAGG
#GGGG
#GGGA
#CAGG
#AGGG
#GGAG"""
#seq_in= input_dna.split("\n")

input_dna = """AAAT
AATG
ACCC
ACGC
ATAC
ATCA
ATGC
CAAA
CACC
CATA
CATC
CCAG
CCCA
CGCT
CTCA
GCAT
GCTC
TACG
TCAC
TCAT
TGCA"""
seq_in  =  input_dna.split("\n") 


##################################################

# Code to perform paired read assembly 

# Initalize reads and check parameters
seqdata =  SingleReadDNASeqData(seq_in) 
seqdata.GetParams()

# Generate DeBruijn Graph, In and Outdegree parameters including if the Debruijn
# is balanced,
seqdata.DeBruijn()
seqdata.InOutDict()
seqdata.StartEndNodes()

#Determine type of function to use based upon how balanced the DeBruijn Graph is

#If data is unbranched run standard Eularian Function
if seqdata.balanced == 'BU' or seqdata.balanced == 'SU':
    seqdata.EularianCycle()
    seqdata.GenomePathReconstruction()
    
# If data is branched run function to assemble into all possible unbranched contigs   
# Alteration of non-braching contigs function to allow for a non empty remaining paths could allow its addtion here    
elif seqdata.balanced == 'BB' or seqdata.balanced == 'SB':
    seqdata.AssemblyNonBranchingContigs()
    

print("\n\nAssembly Data")
print("===========================")
if seqdata.balanced == 'BU':
    print('The read data suggests a circular DNA strand.')
    print('\nAn intact seqeunced was able to be assembled from the provided reads.')
    print('\nAssembled sequence: ' + str(seqdata.assembled))
elif seqdata.balanced == 'BB':
    print('The read data suggests a circular DNA strand.')
    print('Non-branching contigs were assembled from the provided reads. \nThe contigs in the first and last contigs likely have a redundant region of overlap.')
    print('\nAssembled contigs(numpy array): ' + str(seqdata.contigarray))
    print('\nEach row indicates an independant contig. \nAdjacent columns indicate contigs with overlapping edges.')
elif seqdata.balanced == 'SU':
    print('The read data suggests a linear DNA strand.')
    print('\nAn intact seqeunced was able to be assembled from the provided reads.')
    print('\nAssembled sequence: ' + str(seqdata.assembled))
elif seqdata.balanced == 'SB':
    print('The read data suggests a linear DNA strand.')
    print('Non-branching contigs were assembled from the provided reads.')
    print('\nAssembled contigs(numpy array): ' + str(seqdata.contigarray))
    print('\nEach row indicates an independant contig. \nAdjacent columns indicate contigs with overlapping edges.') 
elif seqdata.balanced == 'U':
    print('\n\nA balanced or semi-balanced DeBruijn Graph was not found from the read data.')
    print('Contigs were not able to be assembled.')


####NOTES  
### for balanced paths need to add something that will remove the beginning and end overlap          
# genome path reconstruction already does this but an BB is more complicated  
# also probably possible to adjust non branching contigs funtion to allow for unbalanced paths that leave some unused paths behind.
    





   
    




