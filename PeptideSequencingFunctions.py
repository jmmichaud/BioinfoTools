#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 22 13:41:22 2018

@author: jennifermichaud
"""

import copy
import collections
import numpy as np

    

def GenerateCycloSubstrings(proteinseq):
    """Inputs protein sequence of a cyclic peptide using single letter amino acid
    code.
    Outputs all possible substrings that would be generated by mass spectrometry includes 
    empty frag('') and intact string.
    """
    substrings = ['']
    doubleprotein = proteinseq + proteinseq
    l = 1
    for i in range(1,len(proteinseq)): #i is size of fragment
        proteinlen = len(proteinseq) + i - l #accounts for reducing overlap as i increases
        l += 1
        for j in range(0,proteinlen): #generates all frags of size i
            tempstring = doubleprotein[j:j+i]
            substrings.append(tempstring)
    substrings.append(proteinseq)      
    return substrings


def SubstringCycloMasses(proteinseq):
    """Inputs protein sequence using single letter amino acid
    code.
    Outputs list of integer masses of expected mass spec fragments (all 
    possible substrings of inputted protein sequence including empty fragment
    and intact peptide)."""
    tempmass = 0
    substringmasses = [] 
    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
    substringlist = GenerateCycloSubstrings(proteinseq)
    for string in substringlist:
        if string == '': 
            substringmasses.append(AAtoMassdict[string])
        else:    
            for i in range(0,len(string)):
                tempmass += AAtoMassdict[string[i]]
            substringmasses.append(tempmass)
            tempmass = 0
    substringmasses.sort()
    return substringmasses
 

def GenerateLinearSubstrings(proteinseq):
    """Inputs protein sequence of a cyclic peptide and outputs all possible 
    substrings that would be generated by mass spectrometry includes 
    empty frag('') and intact string"""
    substrings = ['']
    l = 1
    for i in range(1,len(proteinseq)): #i is size of fragment
        proteinlen = len(proteinseq) + i - l #accounts for reducing overlap as i increases
        l += 1
        for j in range(0, proteinlen): #generates all frags of size i
            tempstring = proteinseq[j:j+i]
            if len(tempstring) == i:
                substrings.append(tempstring)
            
    substrings.append(proteinseq)      
    return substrings


def SubstringLinearMasses(proteinseq):
    """inputs protein sequence and outputs list of integer masses of expected 
    mass spec fragments (all possible substrings of inputted protein sequence 
    including empty frag and intact peptide)"""
    tempmass = 0
    substringmasses = [] 
    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
    substringlist = GenerateLinearSubstrings(proteinseq)
    for string in substringlist:
        if string == '': 
            substringmasses.append(AAtoMassdict[string])
        else:    
            for i in range(0,len(string)):
                tempmass += AAtoMassdict[string[i]]
            substringmasses.append(tempmass)
            tempmass = 0
    substringmasses.sort()
    return substringmasses

## TEST DATA               
#protein_in = 'LEQN'   

#protein_in = 'YKVRLRCFHFSTEY'
#protein_in = 'AHEWMFVKDGNE'
#
#
#protein_in = 'FFNDGPHVRQIPQYAVSQASATYGRVCMIGVDPIGFWMCKDRQWAMAQPS'    

  
#print("Cyclospectrum")
#print(" ".join(GenerateCycloSubstrings(protein_in)))
#print(" ".join(list(map(str, SubstringCycloMasses(protein_in)))))
#
#print("Linearspectrum")
#print(" ".join(GenerateLinearSubstrings(protein_in)))
#print(" ".join(list(map(str, SubstringLinearMasses(protein_in)))))


    

def CalcAAFragMass(frag):
    """Inputs an amino acid fragment, and outputs its integer mass.
    """
    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
    mass = 0
    for AA in frag:
        mass += AAtoMassdict[AA]
    return mass

def Countfrags(peptidelength):
    """Inputs linear peptide length (peptidelength).
    Outputs number of fragments that can be generated.
    """
    nfrags = peptidelength + 1
    L = peptidelength - 1
    while L > 0:
        nfrags += L
        L -= 1
    return nfrags    
               
#print(Countfrags(1024))  
        

def RemoveListDuplicates(listoflists):
    """Inputs a list of list of numbers and outputs a list with duplicates
    removed"""
    removedups = []
    for slist in listoflists:
        removedups.append(" ".join(list(map(str, slist))))
    removedups = set(removedups)
    removedups = list(removedups)
    correctedlist = []
    for dlist in removedups:
        temp = list(map(int, dlist.split(' ')))
        correctedlist.append(temp)
    return correctedlist

def Cyclize(linkedspectralist):
    """Inputs a list of ordered integer masses (linkedspectralist) representing 
    peptides. 
    Outputs all cyclic versions of the inputted masses as a list of lists.
    """    
    cyclizelist = []
    L = len(linkedspectralist[0])
    for peptide in linkedspectralist:
        cyclizelist.append(peptide)
        for i in range(1,L):
            cyclist = peptide[i:]
            cyclist.extend(peptide[:i])
            cyclizelist.append(cyclist)
    return cyclizelist

def SimpleCyclopeptideSequencing(spectrum): 
    """Inputs a list of integer masses as that represent a mass spectrum.
    Outputs list of potential peptides represented by the mass spectrum using
    single letter AA codes.
    """
    peptides = []
    AAs = []
    parentmass = max(spectrum)
    looper = 0
    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
    if 0 in spectrum: #remove 0 from spectrum
        spectrum.remove(0)
    for mass in AAmasslist: #Build monopeptide list and start peptides list
        if mass in spectrum:
                peptides.append([mass])
                AAs.append(mass)
    #generate strings consistent with spectra, add all possibilitiess from 
    #monopeptide/AA list and then remove combinations whose mass isn't 
    #consistent with the spectra
    duppeps = copy.deepcopy(peptides)
    peptides = []
    for AA in AAs:  # generate dipeptides
        subcopy = copy.deepcopy(AAs)
        for i in range(len(duppeps)):
            for frag in duppeps[i]:
                subcopy.remove(frag)
            if AA in subcopy:
                templist = copy.deepcopy(duppeps[i])
                templist.append(AA)
                peptides.append(templist)
            subcopy = copy.deepcopy(AAs)   
    peppeps = copy.deepcopy(peptides)        
    for j in range(len(peppeps)):  #remove dipeptides not consistent with mass in spectra 
        sumpeps = sum(peppeps[j]) 
        if sumpeps not in spectrum and sumpeps != parentmass:
            peptides.remove(peppeps[j])
        if sumpeps == parentmass:
            looper += 1
    # while the parentmass is not reached combine peptides consistent with mass 
    #in spectrum to generate new peptide list and overlap excluding the first 
    #element of one fragment and last element of another fragment.
    b=0
    L=2
    while looper == 0: 
        print(b)
        b += 1
        peptidesolve = []
        for j in range(len(peptides)):
            for k in range(len(peptides)):
                if len(peptides[j]) == len(peptides[k]):
                    if peptides[j][1:] == peptides[k][:-1]:
                        plist = peptides[j][:]
                        plist.append(peptides[k][-1])
                        if sum(plist) in spectrum:
                            peptidesolve.append(plist)
                        if sum(plist) == parentmass: #when sum of frags equals parent mass then looper is increased to break loop
                            peptidesolve.append(plist)
                            looper += 1 
        L += 1  #length of peptide increases with each loop
        biggestlist = []
        dupps = copy.deepcopy(peptidesolve)
        for pep in dupps:
            if len(pep) == L:
                biggestlist.append(pep[:])    
        peptides = copy.deepcopy(biggestlist)                    
    peptides = RemoveListDuplicates(peptides) #remove duplicate peptides
    cyclicpeptides = Cyclize(peptides) #generate cyclized version of peptides   
    outputlist = []
    for cycle in cyclicpeptides:
        outputlist.append("-".join(list(map(str, cycle))))
    return " ".join(outputlist) 

##TEST DATA
    
#Spectrum_in = '0 113 128 186 241 299 314 427'
    
#Spectrum_in = '0 71 97 99 103 113 113 114 115 131 137 196 200 202 208 214 226 227 228 240 245 299 311 311 316 327 337 339 340 341 358 408 414 424 429 436 440 442 453 455 471 507 527 537 539 542 551 554 556 566 586 622 638 640 651 653 657 664 669 679 685 735 752 753 754 756 766 777 782 782 794 848 853 865 866 867 879 885 891 893 897 956 962 978 979 980 980 990 994 996 1022 1093'

#Spectrum_in = [0, 113, 114, 128, 129, 227, 242, 242, 257, 355, 356, 370, 371, 484]

Spectrum_in ='0 113 113 114 128 128 186 186 186 227 241 242 299 299 314 314 355 355 372 413 427 427 468 485 500 500 541 541 541 613 613 613 654 654 669 686 727 727 741 782 799 799 840 840 855 855 912 913 927 968 968 968 1026 1026 1040 1041 1041 1154'
#
Spectrum_in = list(map(int, Spectrum_in.split(" ")))
#
answer = SimpleCyclopeptideSequencing(Spectrum_in)
print(answer)  
   
    
def CycloPeptideScoring(peptideseq, spectrum):
    """Inputs a cyclic peptide as an AA string (petideseq) and mass spectra as 
    a list of integers (spectrum).  
    Outputs the score of the peptide against the spectrum.
    Each match of spectrum to a theorectical spectrum generated from the peptide 
    sequence yields one point.
    """
    if peptideseq == []:
        return 0
    else:
        theoreticalspectrum = SubstringCycloMasses(peptideseq)
        score = 0
        for spec in spectrum:
            if spec in theoreticalspectrum:
                score += 1
                theoreticalspectrum.remove(spec)
        return score
    
def LinearPeptideScoring(peptideseq, Spectrum):
    """ Inputs a peptide as an AA string and mass spectra as a list 
    of integers.  
    Outputs the score of the peptide against the spectrum
    Each match of Spectrum to THeorectical spectrum yields
    one point."""
    if peptideseq == []:
        return 0
    else:
        theoreticalspectrum = SubstringLinearMasses(peptideseq)
        Score = 0
        for spec in Spectrum:
            if spec in theoreticalspectrum:
                Score += 1
                theoreticalspectrum.remove(spec)
        return Score



#peptide_in = 'NQEL'
#Spectrum_in = "0 99 113 114 128 227 257 299 355 356 370 371 484"
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))

#peptide_in = 'PEEP'
#Spectrum_in = "0 97 97 97 100 129 194 226 226 226 258 323 323 355 393 452"
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))
        
#peptide_in ='QSSLNFQENVEYSVRNDFSDCIVSGQNEVRVAYYTADANGNPSHTMS'
#Spectrum_in = '0 57 71 71 71 87 87 87 87 87 87 97 99 99 99 99 101 101 103 113 113 113 113 113 114 114 114 114 114 115 115 128 128 128 129 129 131 137 137 144 147 147 156 156 156 163 163 163 171 172 174 184 186 186 186 200 200 212 212 213 215 216 218 218 224 227 227 227 228 228 229 232 234 236 238 241 243 243 244 250 251 255 255 257 257 257 258 262 264 269 269 270 275 275 285 287 292 299 302 314 315 315 319 325 326 328 328 331 335 337 340 340 340 342 342 342 347 349 350 356 357 358 359 359 365 368 369 369 371 372 376 379 383 385 388 391 392 397 402 403 404 413 415 415 422 427 427 428 429 430 438 439 451 454 456 456 456 459 462 464 470 470 471 471 473 474 475 478 478 484 484 496 498 498 503 505 505 505 506 509 510 516 517 518 521 521 526 527 532 532 543 543 552 562 564 567 569 569 571 573 574 575 576 577 577 583 584 585 588 592 592 597 599 602 603 608 608 611 614 617 619 619 620 629 631 634 634 640 645 646 654 656 665 666 671 674 677 682 683 684 687 688 690 690 690 690 691 691 698 707 711 718 720 721 721 728 732 733 733 734 739 744 745 746 748 748 753 755 755 759 761 762 764 765 767 770 785 789 790 791 796 802 804 804 812 815 818 818 819 820 820 821 824 824 826 838 840 843 846 847 847 847 849 853 858 861 861 863 863 866 868 874 876 877 881 883 892 899 902 903 909 911 911 923 925 930 932 933 933 937 939 939 945 946 947 948 948 952 960 961 962 967 975 976 976 976 977 978 982 987 990 996 1003 1010 1012 1016 1023 1024 1024 1024 1032 1033 1036 1037 1038 1039 1046 1047 1047 1047 1048 1059 1059 1061 1074 1074 1076 1078 1079 1088 1089 1090 1093 1095 1095 1095 1095 1104 1107 1109 1110 1111 1117 1123 1124 1130 1135 1138 1146 1146 1149 1149 1150 1158 1160 1160 1161 1161 1161 1175 1183 1187 1188 1192 1194 1194 1196 1203 1205 1206 1208 1209 1209 1210 1218 1222 1223 1223 1231 1237 1237 1245 1245 1250 1251 1251 1251 1260 1263 1274 1275 1280 1282 1288 1289 1291 1296 1298 1302 1302 1307 1309 1312 1317 1320 1321 1322 1322 1323 1324 1324 1325 1331 1332 1333 1336 1338 1350 1352 1359 1364 1365 1367 1373 1374 1375 1378 1379 1381 1389 1397 1404 1408 1409 1411 1412 1413 1416 1423 1424 1426 1431 1435 1435 1438 1438 1445 1446 1449 1452 1463 1468 1474 1475 1475 1478 1480 1480 1486 1487 1488 1492 1493 1495 1503 1510 1511 1522 1530 1537 1537 1538 1539 1541 1544 1545 1545 1546 1551 1552 1553 1559 1564 1568 1576 1577 1577 1579 1587 1589 1591 1600 1601 1606 1608 1616 1617 1622 1624 1627 1631 1632 1636 1638 1638 1647 1651 1658 1659 1666 1666 1666 1667 1667 1667 1667 1678 1681 1690 1690 1692 1693 1703 1704 1707 1714 1714 1715 1721 1723 1724 1731 1737 1750 1754 1755 1760 1761 1766 1772 1777 1778 1780 1780 1780 1780 1780 1785 1794 1794 1795 1795 1801 1802 1805 1808 1815 1823 1827 1828 1828 1837 1839 1844 1851 1852 1853 1859 1865 1868 1876 1879 1885 1891 1894 1894 1895 1900 1902 1908 1908 1909 1914 1914 1915 1916 1917 1922 1936 1941 1942 1942 1947 1948 1955 1958 1965 1966 1967 1972 1973 1978 1999 2007 2007 2008 2008 2009 2014 2015 2016 2018 2023 2023 2028 2035 2042 2046 2047 2049 2051 2052 2055 2055 2062 2063 2070 2071 2071 2080 2086 2094 2106 2112 2120 2122 2122 2133 2134 2137 2139 2142 2145 2145 2146 2151 2152 2154 2159 2164 2165 2167 2170 2170 2172 2174 2177 2183 2183 2184 2185 2193 2199 2199 2230 2233 2235 2241 2244 2251 2254 2259 2265 2266 2267 2269 2270 2278 2279 2282 2283 2285 2286 2287 2289 2296 2298 2298 2298 2301 2306 2333 2336 2349 2356 2356 2357 2358 2369 2370 2377 2379 2380 2382 2383 2385 2386 2388 2395 2397 2400 2401 2402 2411 2412 2414 2421 2423 2426 2432 2434 2437 2470 2482 2482 2484 2485 2485 2487 2492 2498 2499 2505 2511 2513 2514 2514 2516 2516 2519 2519 2522 2524 2526 2533 2533 2535 2539 2540 2568 2569 2569 2584 2598 2598 2601 2604 2606 2613 2615 2620 2623 2626 2627 2629 2635 2643 2646 2648 2648 2653 2654 2655 2655 2656 2663 2682 2691 2691 2697 2698 2713 2716 2726 2736 2738 2740 2742 2747 2754 2756 2760 2761 2762 2762 2762 2767 2771 2783 2784 2790 2791 2811 2813 2827 2827 2839 2841 2841 2853 2854 2854 2861 2861 2867 2873 2875 2875 2877 2884 2890 2904 2910 2912 2918 2918 2941 2948 2950 2954 2954 2955 2955 2960 2970 2983 2988 2989 2990 2991 3003 3011 3017 3024 3031 3031 3040 3046 3051 3057 3069 3075 3078 3082 3085 3090 3097 3102 3102 3104 3111 3118 3125 3130 3145 3153 3159 3159 3169 3172 3177 3182 3189 3196 3198 3206 3212 3217 3230 3240 3244 3246 3254 3258 3265 3267 3268 3269 3272 3281 3305 3313 3325 3326 3329 3331 3333 3339 3343 3345 3357 3359 3380 3382 3382 3393 3396 3416 3427 3428 3430 3444 3444 3444 3446 3453 3453 3461 3482 3494 3495 3506 3509 3511 3517 3529 3531 3531 3556 3558 3574 3581 3582 3583 3593 3600 3607 3608 3609 3623 3639 3645 3645 3657 3668 3669 3680 3682 3694 3710 3714 3722 3722 3728 3736 3738 3756 3769 3770 3786 3801 3808 3813 3823 3831 3835 3836 3841 3843 3851 3857 3857 3866 3900 3900 3914 3922 3928 3932 3944 3949 3960 3965 3971 3979 3985 3987 4013 4015 4027 4036 4059 4061 4063 4072 4078 4093 4098 4114 4126 4141 4143 4150 4160 4165 4173 4185 4192 4201 4206 4240 4254 4254 4272 4274 4279 4291 4293 4302 4329 4341 4353 4367 4368 4378 4400 4403 4405 4428 4430 4440 4454 4481 4481 4492 4531 4534 4541 4556 4568 4568 4577 4594 4621 4655 4662 4669 4678 4681 4681 4705 4749 4768 4768 4783 4806 4809 4818 4855 4896 4896 4905 4919 4937 4983 4992 5006 5024 5050 5093 5120 5137 5137 5221 5224 5224 5311 5352 5439'
#
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))

#print(CycloPeptideScoring(peptide_in, Spectrum_in))
#print(LinearPeptideScoring(peptide_in, Spectrum_in)) 


def GenerateCycloSpectra(peptidemasses):
    """Inputs a list of integer masses (min 2 fragments) of a cyclic peptide.
    Outputs the expanded spectra (sums of adjacent fragments) as a list of masses.
    """
    expandedspectra = []
    L = len(peptidemasses) 
    for peptide in peptidemasses:
        expandedspectra.append(peptide)
    expandedspectra.append(sum(peptidemasses))
    i = 2
    while i < L:
#        print(L)
        for n in range(L):
            mass = peptidemasses[n:n+i]
#            print(mass)
#            print(len(mass))
            if len(mass) < i:
#                print("short")
                mass = peptidemasses[n:]
#                print(mass)
                frontneeded = i - len(mass)
#                print(frontneeded)
                mass.extend(peptidemasses[:frontneeded])
#                print(mass)
            masssum = sum(mass)              
            expandedspectra.append(masssum)
#            print(mass)
#            print(masssum)                
#        for n in range(L):            
#            try:
#                mass = peptidemasses[n:n+i]
#                masssum = sum(mass)
#                expandedspectra.append(masssum)
#            except:
#                print("except")
#                mass = peptidemasses[n:]
#                frontneeded =  L - len(mass) + 1
#                mass.extend(peptidemasses[:frontneeded])
#                masssum = sum(mass)
#                expandedspectra.append(masssum)
#            print(mass)
#            print(masssum)
        i += 1
    expandedspectra.sort()   
    return expandedspectra

def GenerateLinearSpectra(peptidemasses):
    """Inputs a list of integer masses (min 2 fragments) of a linear peptide.
    Outpus the expanded spectra (sums of adjacent fragments) as a list of masses"""
    expandedspectra = []
    L = len(peptidemasses) 
    for peptide in peptidemasses:
        expandedspectra.append(peptide)
    expandedspectra.append(sum(peptidemasses))
    i = 2
    while i < L:
#        print(L)
        for n in range(L):
            mass = peptidemasses[n:n+i]
#            print(mass)
#            print(len(mass))
            if len(mass) == i:
                masssum = sum(mass)              
                expandedspectra.append(masssum)
        i += 1
    expandedspectra.sort()      
    return expandedspectra

#peptidemasses_in = [71, 113, 129]
#print(GenerateLinearSpectra(peptidemasses_in))

def PeptideCycloScoring(peptideseq, spectrum):
    """Inputs a cyclic peptide (peptideseq) as a list of integers and mass 
    spectra (spectrum) as a list of integers.  
    Outputs the score of the peptide spectrum generated from peptideseq against 
    the inputted spectrum.
    Each match of the peptide generated spectrum to the inputted spectrum yields
    one point. 
    """
#    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: '(I/L)', 114: 'N', 115: 'D', 128: '(K/Q)', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'}
    if peptideseq == []:
        return 0
    else:
        peptidemasses = GenerateCycloSpectra(peptideseq)
        score = 0
#        print(peptidemasses)
        specdup = copy.deepcopy(spectrum)
        for spec in peptidemasses:
#            print(spec)
            if spec in specdup:
#                print(spectrum)
                score += 1
#                print("Score")
#                print(score)
                specdup.remove(spec) #remove mass from spectrum to avoid duplicates
        return score

def PeptideLinearScoring(peptideseq, spectrum):
    """Inputs a linear peptide as a list of integers (peptideseq)
    and mass spectra as a list of integers (spectrum).  
    Outputs the score of the peptide generated spectrum against the 
    inputted spectrum.
    Each match of the peptide generated spectrum to the inputted spectrum yields
    one point. 
    """
#    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: '(I/L)', 114: 'N', 115: 'D', 128: '(K/Q)', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'}
    if peptideseq == []:
        return 0
    else:
        peptidemasses = GenerateLinearSpectra(peptideseq)
        score = 0
#        print(peptidemasses)
        specdup = copy.deepcopy(spectrum)
        for spec in peptidemasses:
#            print(spec)
            if spec in specdup:
#                print(Spectrum)
                score += 1
#                print("Score")
#                print(score)
                specdup.remove(spec) #remove mass from spectrum to avoid duplicates
        return score
       
        
def TrimPeptideLeaderboard(leaderboard, spectrum, N):
    """Inputs a list of lists of candidate peptides for an unknown peptide
    as a leaderboard for the spectrum of the unknown peptide. Outputs candidate 
    peptides with N number of top scores.
    """  
#    print(leaderboard)
    toppeptides = []
    scoredict = {}
    scorelist = []
    scoreset = []
    for peptide in leaderboard:
#        print(peptide)
        peptidejoin = ' '.join(list(map(str, peptide)))
        peptidescore = PeptideLinearScoring(peptide, spectrum)
#        if type(peptide) == list:
##            print(peptide)
        scoredict[peptidejoin] = peptidescore 
        scorelist.append(peptidescore)
        scoreset.append(peptidescore)
#    print(scoredict)
    scoredict = collections.OrderedDict(scoredict)
    scoredict = sorted(scoredict.items(), key=lambda t: t[1], reverse = True)
#    print(scoredict)
    scorelist.sort(reverse= True)
    scoreset = list(set(scoreset))
    scoreset.sort(reverse= True)
#    print(scoreset)
    #Find number of items you need from dictionary (C) for top N scores including ties
    #create dictionary, countdict to count number of each score
    countdict = {}
    for sco in scorelist:
        if sco in countdict:
            countdict[sco] += 1
        else:
            countdict[sco] = 1       
#    print(countdict)
    #Use set of scores and countdict to determine the number,C, of topscores to take
    Z = 0
    C = 0
    for sc in scoreset:
        Z += countdict[sc]
        if Z >= N:
            C = Z
            break
    if C != Z:
        C = Z
        
#    print(C)
    L = 0       
    for pep in scoredict:
        if L < C:
            toppeptide = pep[0]
            if ' ' in toppeptide:
                toppeptide = list(map(int, toppeptide.split(" ")))
            else:
                toppeptide = [int(toppeptide)]
            toppeptides.append(toppeptide)
            L += 1
#    print(toppeptides)
    return toppeptides
        
            
#leaderboard_in = ['LAST', 'ALST', 'TLLT', 'TQAS']
#Spectrum_in = '0 71 87 101 113 158 184 188 259 271 372'
#N_in = 2    

#leaderboard_in = 'IWAEQEMNHTEASPRRLTYHWSVAWFWEAFEYTYQADCM APFHLEMAVVDSWKYVTKNTYGEMMRATIIASEDDEMDT RCSIYGKFFVTYHHESMTIFIFEHDIHKYGQMFSIPLGE GDYMQKENDHPHETTQLWSCWWIPCWDCGTCLDKMHQST CTQMSWSTSRLFLSHLDDEWVEFYMKWDEVTVCAGVTPL FQCRAGVVIPVMTFCERGALMQGRAHDPDFLDANMQKEM RNSCKTAYIQHLHKQEKMVQLRNQSDHHHWEHDGRVIKP EINLHGGENMNTTKDTVVRQYTFFKSPIVKFCVGHHCSC DGHYGPNQGLPWRNIRYIKIGFDESMLMFGESEEKIPPK VMGKFMIGARQAPCPLQQPAGGEGLPFRIGQQKIEMNWC WVCIYHIMDQSYRGNPALLKLKWNDWRDRICGKPNKDWL LVAIPYYWQYYWAETYYNTADAWSPEVCISFSPDMNTTD NLFYDGMAQPLGFFCIHRYRRLYMRHNQVYAGNTKQWQN PVQVPHINQCEFQHCNWEDLNQWVDECNEMCLCWTMWHK HRVFWHLEMCKPQTRNIFFHVGNMSSCFQSMETIHKRFG QVCICEFHEYKWCIYHRFKWEKMYDYNWVKEFNFTWCTY PKKHKGHTTATVACKKFEIHKDPEMFEFGEYFDKNYLES KERFHIVVACQLQCFIYMQASYKDAYAMFHNHLHGVRWK'
#Spectrum_in = '0 57 71 71 71 71 87 97 97 97 99 99 99 101 101 103 113 113 114 114 128 128 128 128 129 129 129 129 129 129 129 131 137 137 147 147 163 163 168 170 184 185 185 185 186 186 186 210 211 214 215 218 224 225 226 226 227 228 228 230 236 241 250 256 257 257 258 260 262 264 266 276 276 276 281 282 282 286 289 298 299 300 313 314 314 315 317 323 332 338 339 342 343 347 351 353 354 356 356 357 364 365 373 377 378 385 385 387 391 395 399 399 405 405 410 413 420 429 429 436 439 442 442 443 446 449 451 461 462 465 467 471 476 484 484 484 485 485 486 486 488 490 496 500 502 506 519 524 528 528 528 533 536 541 543 549 550 557 558 562 568 568 571 571 583 587 590 590 598 599 602 603 613 614 615 618 619 621 622 625 627 629 637 646 647 647 649 656 657 659 661 670 671 671 673 686 687 697 698 699 700 701 704 708 712 715 715 716 716 718 720 744 746 747 750 756 758 772 772 774 775 784 784 785 785 786 787 788 789 799 800 800 807 815 827 828 829 829 833 841 844 844 844 847 849 849 871 872 875 883 884 884 885 885 887 900 900 901 901 901 903 913 913 918 935 936 941 943 946 955 957 962 970 970 970 972 973 975 982 986 988 1000 1002 1012 1012 1012 1012 1013 1013 1014 1014 1015 1017 1022 1028 1032 1054 1064 1069 1070 1071 1071 1073 1083 1086 1086 1099 1099 1099 1104 1109 1110 1111 1111 1115 1117 1125 1129 1131 1140 1141 1141 1142 1149 1151 1157 1159 1161 1165 1180 1183 1185 1198 1199 1200 1200 1201 1228 1228 1236 1236 1239 1239 1240 1243 1246 1248 1252 1254 1256 1258 1264 1269 1269 1269 1270 1278 1288 1290 1294 1296 1299 1314 1314 1317 1326 1327 1335 1337 1340 1365 1367 1368 1368 1369 1375 1377 1385 1385 1386 1387 1387 1389 1391 1393 1397 1398 1399 1406 1425 1431 1446 1451 1454 1455 1462 1464 1466 1469 1474 1488 1490 1493 1496 1496 1498 1498 1499 1500 1500 1502 1503 1505 1515 1522 1528 1545 1545 1553 1560 1571 1572 1583 1584 1590 1592 1595 1595 1599 1599 1600 1601 1603 1614 1616 1616 1627 1630 1632 1633 1635 1643 1657 1659 1674 1682 1685 1685 1690 1701 1712 1713 1719 1720 1724 1727 1728 1728 1729 1729 1730 1731 1732 1742 1755 1756 1763 1772 1777 1784 1786 1788 1798 1802 1802 1811 1819 1826 1827 1827 1842 1850 1856 1856 1857 1859 1861 1871 1871 1873 1883 1889 1895 1897 1898 1906 1913 1915 1916 1930 1940 1948 1949 1954 1955 1958 1970 1972 1984 1986 1987 1994 2000 2008 2013 2024 2026 2029 2035 2036 2041 2041 2043 2044 2052 2069 2083 2084 2085 2086 2095 2098 2101 2114 2123 2123 2137 2139 2140 2141 2143 2154 2155 2166 2169 2170 2171 2173 2182 2198 2211 2212 2213 2214 2214 2226 2238 2240 2251 2252 2253 2269 2270 2272 2276 2280 2282 2284 2299 2300 2310 2311 2339 2340 2342 2345 2351 2355 2367 2375 2377 2379 2380 2399 2399 2400 2400 2401 2413 2416 2436 2439 2439 2446 2448 2464 2468 2471 2479 2484 2500 2503 2508 2514 2517 2527 2528 2530 2535 2560 2565 2565 2568 2570 2576 2586 2597 2613 2627 2629 2631 2631 2631 2642 2655 2656 2657 2689 2694 2694 2698 2699 2702 2705 2712 2728 2739 2741 2742 2744 2745 2756 2757 2760 2784 2799 2815 2816 2823 2836 2838 2841 2841 2841 2842 2859 2868 2870 2870 2885 2885 2912 2913 2913 2929 2942 2967 2967 2970 2970 2970 2984 2988 2998 2998 2999 3022 3026 3026 3041 3055 3071 3095 3096 3097 3098 3099 3117 3123 3125 3126 3155 3183 3184 3185 3188 3194 3200 3223 3224 3227 3246 3252 3280 3284 3288 3302 3312 3313 3317 3323 3347 3352 3355 3387 3399 3409 3409 3413 3418 3431 3441 3460 3470 3483 3516 3528 3531 3532 3538 3538 3540 3541 3588 3599 3629 3644 3645 3659 3667 3669 3669 3685 3700 3726 3742 3756 3772 3773 3798 3813 3814 3829 3855 3870 3870 3885 3941 3945 3958 3967 3984 3999 4016 4038 4087 4096 4130 4131 4167 4202 4227 4234 4298 4305 4316 4413 4419 4484 4516 4587'
#N_in = 6
#
#leaderboard_in = leaderboard_in.split(" ")
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))
##    
#print(' '.join(TrimPeptideLeaderboard(leaderboard_in, Spectrum_in, N_in)))    
        

#leaderboard_in = [[57, 57], [71, 57], [87, 57], [97, 57], [99, 57], [101, 57], [103, 57], [113, 57], [114, 57], [115, 57], [128, 57], [129, 57], [131, 57], [137, 57], [147, 57], [156, 57], [163, 57], [186, 57], [57, 71], [71, 71], [87, 71], [97, 71], [99, 71], [101, 71], [103, 71], [113, 71], [114, 71], [115, 71], [128, 71], [129, 71], [131, 71], [137, 71], [147, 71], [156, 71], [163, 71], [186, 71], [57, 87], [71, 87], [87, 87], [97, 87], [99, 87], [101, 87], [103, 87], [113, 87], [114, 87], [115, 87], [128, 87], [129, 87], [131, 87], [137, 87], [147, 87], [156, 87], [163, 87], [186, 87], [57, 97], [71, 97], [87, 97], [97, 97], [99, 97], [101, 97], [103, 97], [113, 97], [114, 97], [115, 97], [128, 97], [129, 97], [131, 97], [137, 97], [147, 97], [156, 97], [163, 97], [186, 97], [57, 99], [71, 99], [87, 99], [97, 99], [99, 99], [101, 99], [103, 99], [113, 99], [114, 99], [115, 99], [128, 99], [129, 99], [131, 99], [137, 99], [147, 99], [156, 99], [163, 99], [186, 99], [57, 101], [71, 101], [87, 101], [97, 101], [99, 101], [101, 101], [103, 101], [113, 101], [114, 101], [115, 101], [128, 101], [129, 101], [131, 101], [137, 101], [147, 101], [156, 101], [163, 101], [186, 101], [57, 103], [71, 103], [87, 103], [97, 103], [99, 103], [101, 103], [103, 103], [113, 103], [114, 103], [115, 103], [128, 103], [129, 103], [131, 103], [137, 103], [147, 103], [156, 103], [163, 103], [186, 103], [57, 113], [71, 113], [87, 113], [97, 113], [99, 113], [101, 113], [103, 113], [113, 113], [114, 113], [115, 113], [128, 113], [129, 113], [131, 113], [137, 113], [147, 113], [156, 113], [163, 113], [186, 113], [57, 114], [71, 114], [87, 114], [97, 114], [99, 114], [101, 114], [103, 114], [113, 114], [114, 114], [115, 114], [128, 114], [129, 114], [131, 114], [137, 114], [147, 114], [156, 114], [163, 114], [186, 114], [57, 115], [71, 115], [87, 115], [97, 115], [99, 115], [101, 115], [103, 115], [113, 115], [114, 115], [115, 115], [128, 115], [129, 115], [131, 115], [137, 115], [147, 115], [156, 115], [163, 115], [186, 115], [57, 128], [71, 128], [87, 128], [97, 128], [99, 128], [101, 128], [103, 128], [113, 128], [114, 128], [115, 128], [128, 128], [129, 128], [131, 128], [137, 128], [147, 128], [156, 128], [163, 128], [186, 128], [57, 129], [71, 129], [87, 129], [97, 129], [99, 129], [101, 129], [103, 129], [113, 129], [114, 129], [115, 129], [128, 129], [129, 129], [131, 129], [137, 129], [147, 129], [156, 129], [163, 129], [186, 129], [57, 131], [71, 131], [87, 131], [97, 131], [99, 131], [101, 131], [103, 131], [113, 131], [114, 131], [115, 131], [128, 131], [129, 131], [131, 131], [137, 131], [147, 131], [156, 131], [163, 131], [186, 131], [57, 137], [71, 137], [87, 137], [97, 137], [99, 137], [101, 137], [103, 137], [113, 137], [114, 137], [115, 137], [128, 137], [129, 137], [131, 137], [137, 137], [147, 137], [156, 137], [163, 137], [186, 137], [57, 147], [71, 147], [87, 147], [97, 147], [99, 147], [101, 147], [103, 147], [113, 147], [114, 147], [115, 147], [128, 147], [129, 147], [131, 147], [137, 147], [147, 147], [156, 147], [163, 147], [186, 147], [57, 156], [71, 156], [87, 156], [97, 156], [99, 156], [101, 156], [103, 156], [113, 156], [114, 156], [115, 156], [128, 156], [129, 156], [131, 156], [137, 156], [147, 156], [156, 156], [163, 156], [186, 156], [57, 163], [71, 163], [87, 163], [97, 163], [99, 163], [101, 163], [103, 163], [113, 163], [114, 163], [115, 163], [128, 163], [129, 163], [131, 163], [137, 163], [147, 163], [156, 163], [163, 163], [186, 163], [57, 186], [71, 186], [87, 186], [97, 186], [99, 186], [101, 186], [103, 186], [113, 186], [114, 186], [115, 186], [128, 186], [129, 186], [131, 186], [137, 186], [147, 186], [156, 186], [163, 186], [186, 186]]
#Spectrum_in = '0 71 113 129 147 200 218 260 313 331 347 389 460'
#
#N_in = 10
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))
#print(TrimPeptideLeaderboard(leaderboard_in, Spectrum_in, N_in))
# I think this currently isn't working for these example data because I 
#likely adapted code to accept peptide spectra as masses not a single code AA peptide sequences as is in the examples.        
#  it seems to work fine when called within other functions.
    

def LeaderboardCyclopeptideSequencing(spectrum, N):
    """Inputs an integer (N) and a cyclopeptide spectrum as list of integer masses. 
    Outputs a top scoring peptide as a list of integer masses which is the 
    result of iterative building of a leaderboard spectrum list and trimming to 
    keep entries with N top scores against the original spectrum. It is an efficient 
    algorithm as it trims the list each iteration.
    """    
    leaderboard = []
    leaderpeptide = []
#    peptides = []
    parentmass = max(spectrum)
    looper = 0
    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
    if 0 in spectrum: #remove 0 from spectrum
        spectrum.remove(0)
    monocount = 0
    for spec in spectrum: # the peptide sequence should be as long as monopeptides present in spectra (unless it is missing from spectra)
        if spec <= 186:
            monocount += 1
    for mass in AAmasslist: #Build monopeptide list and start peptides list uses all AAs in case it is missing from spectra
        leaderboard.append([mass])
#    print(leaderboard)
#    leaderboard = Trim(leaderboard, Spectrum, N)
#    print(leaderboard)   
#    b=0
    while looper == 0: #generate strings consistent with spectra, add all possibilitiess from monopeptide/AA list and then remove combinations whose mass isn't consistent with the spectra
#        print(b)
#        b += 1
        duppeps = copy.deepcopy(leaderboard)
        leaderboard = []
        for AA in AAmasslist: # generate extended peptides and add to leaderboard
#           subcopy = copy.deepcopy(Spectrum)
            for i in range(len(duppeps)):
#            for frag in duppeps[i]:
#                subcopy.remove(frag)
                templist = copy.deepcopy(duppeps[i])
                templist.append(AA)
                leaderboard.append(templist)
#        print(leaderboard)
    
#        leaderboard = Trim(leaderboard, Spectrum, N)
        leadups = copy.deepcopy(leaderboard)
        for dup in leadups: # check peptide sum, if sum equal parent mass spectra reached.  If it is greater than parent mass, remove.
            if sum(dup) == parentmass:
#                print(dup)
#                print(sum(dup))
#                print(parentmass)
                if len(dup) >= monocount: #if number of AA in peptide reached (monocount) looper is increased to break loop. 
                    looper += 1
                if PeptideCycloScoring(dup, spectrum) > PeptideCycloScoring(leaderpeptide, spectrum):
                    leaderpeptide = copy.deepcopy(dup)
            elif sum(dup) > parentmass:
                    leaderboard.remove(dup)
#        print(leaderboard)
        leaderboard = TrimPeptideLeaderboard(leaderboard, spectrum, N)  # Trim list.  Keep values of top N scores
#        print(leaderboard)
#        print(looper)
#    print(leaderpeptide)
    return leaderpeptide

                   
#Spectrum_in = '0 71 113 129 147 200 218 260 313 331 347 389 460'
#
#N_in = 10
#Sample out 113-147-71-129  its a cyclopeptide so adjacency is important but order isn't
#
#Spectrum_in = '0 71 71 99 113 113 113 114 114 115 128 128 128 131 131 137 137 137 147 147 156 156 163 184 184 199 213 227 230 234 241 246 251 251 259 260 260 262 265 268 284 284 293 293 297 298 310 312 331 344 350 362 364 367 374 375 381 388 393 396 407 407 411 415 421 421 421 423 435 444 459 475 481 481 494 494 495 503 506 506 509 520 521 530 535 535 548 552 552 558 558 565 574 591 607 609 618 622 622 622 634 634 634 637 648 651 666 667 672 677 678 689 693 695 704 705 719 721 735 737 746 762 765 765 765 769 774 781 785 788 790 792 803 806 806 814 832 833 851 856 858 868 880 882 884 896 902 902 902 902 902 916 918 919 920 927 928 929 953 969 979 987 989 996 997 1011 1014 1015 1015 1016 1027 1030 1033 1033 1039 1041 1055 1057 1058 1066 1068 1085 1086 1100 1116 1126 1128 1129 1140 1142 1143 1148 1152 1153 1158 1161 1169 1170 1180 1181 1186 1195 1199 1199 1200 1213 1213 1240 1247 1256 1266 1268 1271 1276 1279 1289 1295 1295 1299 1309 1312 1313 1317 1317 1323 1326 1327 1337 1339 1341 1346 1350 1399 1403 1408 1410 1412 1422 1423 1426 1432 1432 1436 1437 1440 1450 1454 1454 1460 1470 1473 1478 1481 1483 1493 1502 1509 1536 1536 1549 1550 1550 1554 1563 1568 1569 1579 1580 1588 1591 1596 1597 1601 1606 1607 1609 1620 1621 1623 1633 1649 1663 1664 1681 1683 1691 1692 1694 1708 1710 1716 1716 1719 1722 1733 1734 1734 1735 1738 1752 1753 1760 1762 1770 1780 1796 1820 1821 1822 1829 1830 1831 1833 1847 1847 1847 1847 1847 1853 1865 1867 1869 1881 1891 1893 1898 1916 1917 1935 1943 1943 1946 1957 1959 1961 1964 1968 1975 1980 1984 1984 1984 1987 2003 2012 2014 2028 2030 2044 2045 2054 2056 2060 2071 2072 2077 2082 2083 2098 2101 2112 2115 2115 2115 2127 2127 2127 2131 2140 2142 2158 2175 2184 2191 2191 2197 2197 2201 2214 2214 2219 2228 2229 2240 2243 2243 2246 2254 2255 2255 2268 2268 2274 2290 2305 2314 2326 2328 2328 2328 2334 2338 2342 2342 2353 2356 2361 2368 2374 2375 2382 2385 2387 2399 2405 2418 2437 2439 2451 2452 2456 2456 2465 2465 2481 2484 2487 2489 2489 2490 2498 2498 2503 2508 2515 2519 2522 2536 2550 2565 2565 2586 2593 2593 2602 2602 2612 2612 2618 2618 2621 2621 2621 2634 2635 2635 2636 2636 2636 2650 2678 2678 2749'
#
#N_in = 331
#
#

#Spectrum_in = list(map(int, Spectrum_in.split(" ")))
##
#print("-".join(list(map(str, LeaderboardCyclopeptideSequencing(Spectrum_in, N_in)))))

   

def TopLeaderboardCyclopeptideSequencing(spectrum, N):
    """Inputs an integer (N) and a mass spectrum as list of integer
    masses. Outputs all lead peptides of a maximized score as '\n' seperated 
    entries where each peptide is '-' seperated mass values that represent a 
    monopeptide structure. Allows for non-standard amino acids and takes 
    advantage of both using a leader board to keep N top scoring peptides and 
    scoring comparing the spectrum to each generated spectra of peptides from 
    the leaderboard to generate a leader peptide list where each peptide is a
    maximal achieved score.  Can be adjusted to generate linear peptide
    sequences by using different scoring algorithms indicated in the code.
    """  
    leaderboard = []
    leaderpeptides = []
#    monopeptides = []
    parentmass = max(spectrum)
    looper = 0
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
    AAmasslist = list(range(57,201)) #use to account for non-standard peptides)
    if 0 in spectrum: #remove 0 from spectrum
        spectrum.remove(0)
       
#    monocount = 0
#    for spec in Spectrum:
#        if spec <= 200:
#            monocount += 1
#            monopeptides.append(spec) 
#            leaderboard.append([spec])
#    for mass in AAmasslist:
#        if mass not in monopeptides:
#            monopeptides.append(mass)
#            leaderboard.append([mass])
#    monopeptides.sort()
    monocount = 0
    for spec in spectrum:  #Build monopeptide list 
        if spec <= 200:
            monocount += 1
    for mass in AAmasslist: #Start leadboard peptide list
        leaderboard.append([mass])
#    print(leaderboard)
    
    b=0
#    while b < 1:
    while looper < 6: #generate strings consistent with spectra, add all possibilitiess from monopeptide/AA list and then remove combinations whose mass isn't consistent with the spectra
        #the looper adjusts tolerance, increases length of final peptide examined
        print(b)
        b += 1
        duppeps = copy.deepcopy(leaderboard)
        leaderboard = []
   
        for AA in AAmasslist:  # generate extended peptides
#           subcopy = copy.deepcopy(spectrum)
            for i in range(len(duppeps)):
#            for frag in duppeps[i]:
#                subcopy.remove(frag)
                templist = copy.deepcopy(duppeps[i])
                templist.append(AA)
                leaderboard.append(templist)
        leadups = copy.deepcopy(leaderboard)
        if len(leadups[0]) >= monocount: #if number of AA in peptide reached (monocount) looper is increased to break loop. In this algorithm it is allowed to loop for 5 additional times past the parent mass being reached to allow for further optimization
            looper += 1
        for dup in leadups:
            if sum(dup) == parentmass: #if sum of peptides matches parent mass it is added to leaderpeptides list
                if leaderpeptides == []:
                    leaderpeptides.append(copy.deepcopy(dup))
#                print(dup)
#                print(sum(dup))
#                print(parentmass)
                    
                #Code can be adjusted to generate a linear peptide by altering scoring algorithms
#                dupscore =  PeptideLinearScoring(dup, spectrum)
#                lpscore =  PeptideLinearScoring(leaderpeptides[0], spectrum)   
                dupscore =  PeptideCycloScoring(dup, spectrum)
                lpscore =  PeptideCycloScoring(leaderpeptides[0], spectrum)
                if dupscore > lpscore:  #if the score of the current peptide list is better than the top scoring peptide list,  list is started new with the new peptide list.  
                    leaderpeptides = []
                    leaderpeptides.append(copy.deepcopy(dup))
                elif dupscore == lpscore: #if the score of the current peptide list is equal to those already in the leaderpeptide list it is appended.
                    leaderpeptides.append(copy.deepcopy(dup))

            elif sum(dup) > parentmass:  #if sum of peptides is greater than the parent mass it is removed.
                    leaderboard.remove(dup)
#        print(leaderpeptides)
    
        leaderboard = TrimPeptideLeaderboard(leaderboard, spectrum, N) # Trim list.  Keep values of top N scores
#        print(leaderboard)
#        print(looper)
#    print(leaderpeptide)
    outputlist = []
    for lead in leaderpeptides:
        outputlist.append("-".join(list(map(str, lead))))
    print(len(outputlist))    
    return ' '.join(outputlist)

#Spectrum_in = '0 97 99 113 114 115 128 128 147 147 163 186 227 241 242 244 244 256 260 261 262 283 291 309 330 333 340 347 385 388 389 390 390 405 435 447 485 487 503 504 518 544 552 575 577 584 599 608 631 632 650 651 653 672 690 691 717 738 745 770 779 804 818 819 827 835 837 875 892 892 917 932 932 933 934 965 982 989 1039 1060 1062 1078 1080 1081 1095 1136 1159 1175 1175 1194 1194 1208 1209 1223 1322'

#Spectrum_in ='0 97 99 114 128 147 147 163 186 227 241 242 244 260 261 262 283 291 333 340 357 385 389 390 390 405 430 430 447 485 487 503 504 518 543 544 552 575 577 584 632 650 651 671 672 690 691 738 745 747 770 778 779 804 818 819 820 835 837 875 892 917 932 932 933 934 965 982 989 1030 1039 1060 1061 1062 1078 1080 1081 1095 1136 1159 1175 1175 1194 1194 1208 1209 1223 1225 1322'
#
#N_in = 1000
#
#
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))
#
#tanswer = TopLeaderboardCyclopeptideSequencing(Spectrum_in, N_in)
#print(tanswer)

def AmendSpectrum(spectrum):
    """Inputs a mass spectrum as a list of integers.
    Outputs a convoluted list of masses (all non-zero products when
    elements of spectrum are subtracted from one another). Helpful to fill in 
    missing masses from spectra.
    """
    convoluted = []
    if 0 not in spectrum: 
       spectrum.append(0)
    spectrum.sort(reverse = True)
    for i in range(0,len(spectrum)-1):
        for j in range(i+1,len(spectrum)):
            newmass = spectrum[i] - spectrum[j]
            if newmass != 0:
                convoluted.append(newmass)
    convoluted.sort()        
    return convoluted
    
    
#Spectrum_in = '0 137 186 323'
#
##Spectrum_in = '0 57 118 179 236 240 301'
#
##Spectrum_in = '843 872 644 244 301 227 257 700 871 415 543 915 516 332 731 216 445 115 584 644 916 446 171 272 372 672 515 858 528 315 356 559 715 229 743 128 99 103 503 443 471 744 571 747 815 129 340 101 973 972 658 755 687 616 618 974 988 387 212 856 1087 860 572 642 114 429 959 1030 113 469 286 400 57 641 344 830 231 215 772 984 172 958 544 959 986 443 343 875 786 128 0 801'
##    
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))  
##   
#print(" ".join(list(map(str, AmendSpectrum(Spectrum_in)))))
    
def CorrectedAAList(spectrum, M):
    """Inputs a mass spectrum as a list of integers and an integer (M).
    Generates a list of masses that represent the likely ammino acids present in
    the spectra.  Uses all non-zero products when elements of spectrum are 
    subtracted from one another and a dictionary to count the number of times a 
    mass appears in the amended mass list.  
    Ouputs a list of  the top M masses (with ties) between 57-200 that appear a 
    minimum of M times in the convoluted mass list. 
    """
    spectrum.sort(reverse = True)
    
    convoluted = [] #generate convoluted mass list
    for i in range(0,len(spectrum)-1):
        for j in range(i+1,len(spectrum)):
            newmass = spectrum[i] - spectrum[j]
            if newmass != 0:
                convoluted.append(newmass)
    convoluted.sort() 
    cl = copy.deepcopy(convoluted) # Remove masses not between 57 - 200
    for mass in cl:
        if mass < 57 or mass > 200:
            convoluted.remove(mass)

    
    convolutedcountd = {} #create dictionary, convolutedcountd to count number of each score
    for num in convoluted:
        if num in convolutedcountd:
            convolutedcountd[num] += 1
        else:
            convolutedcountd[num] = 1 
    scorelist = []
    for key in convolutedcountd:
        scorelist.append(convolutedcountd[key])
    scoredict = collections.OrderedDict(convolutedcountd) #Use set of masses and countdict to determine the number,C, of topscores to take
    scoredict = sorted(scoredict.items(), key=lambda t: t[1], reverse = True)
    scorelist.sort(reverse= True)
#    print(scoredict)
    scoreset = list(set(scorelist))
    scoreset.sort(reverse= True)
  
    countdict = {}  #create another dictionary 
    for sco in scorelist:
        if sco in countdict:
            countdict[sco] += 1
        else:
            countdict[sco] = 1    
    Z = 0
    C = 0
    for sc in scoreset:#Find number of items you need from dictionary (C) for top N scores including ties
        Z += countdict[sc]
        if Z >= M:
            C = Z
            break
    if C != Z:
        C = Z    
    #generate masses    
    L = 0 
    AAmasslist = []      
    for AAmass in scoredict:
        if L < C:
            AAmasslist.append(AAmass[0])
            L += 1   
            
    AAmasslist.sort()
    return AAmasslist

#Spectrum_in = '0 57 118 179 236 240 301'
#
##Spectrum_in = '843 872 644 244 301 227 257 700 871 415 543 915 516 332 731 216 445 115 584 644 916 446 171 272 372 672 515 858 528 315 356 559 715 229 743 128 99 103 503 443 471 744 571 747 815 129 340 101 973 972 658 755 687 616 618 974 988 387 212 856 1087 860 572 642 114 429 959 1030 113 469 286 400 57 641 344 830 231 215 772 984 172 958 544 959 986 443 343 875 786 128 0 801'
##    
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))  
##   
#print(" ".join(list(map(str, CorrectedAAList(Spectrum_in, 20)))))

            
def CyclopeptideSequencing(spectrum, M, N):
    """Inputs two integers (M and N) and a mass spectrum of an unknown 
    cyclopeptide as list of integer masses. 
    Outputs all lead peptides of a maximal score using N as a cutoff for the Trim
    function including ties as a list of lists where  each peptide is a list 
    of integer masses. 
    Uses an AA list generated from processing of the 
    spectrum and returning M topscoring masses between 57 - 200 including ties.
    Allows for non-standard amino acids and takes advantage of both using a leader 
    board to keep N top scoring peptides and scoring algorithsm that compare 
    the spectrum to each generated spectra of peptides from the leaderboard to 
    generate a leader peptide list where each peptide is maximal achieved score.  
    Can be adjusted to generate linear peptide sequences by using different 
    scoring algorithms indicated in the code.
    """  
    leaderboard = []
    leaderpeptides = []
    parentmass = max(spectrum)
    looper = 0
    AAmasslist = CorrectedAAList(spectrum, M)
    if 0 in spectrum: #remove 0 from spectrum
        spectrum.remove(0)

#    monocount = 0
#    for spec in Spectrum:
#        if spec <= 200:
#            monocount += 1
#            monopeptides.append(spec) 
#            leaderboard.append([spec])
#    for mass in AAmasslist:
#        if mass not in monopeptides:
#            monopeptides.append(mass)
#            leaderboard.append([mass])
#    monopeptides.sort()
    monocount = 0
    monopeptides = []
    for spec in spectrum: #Build AA list
        if spec <= 200:
            monocount += 1
            leaderboard.append([spec])
            monopeptides.append(spec)

    for mass in AAmasslist: #Start peptide list
        if mass not in monopeptides:
            leaderboard.append([mass])
#    print(leaderboard)
    
    b=0
#    while b < 1:
    while leaderboard != []: #generate strings consistent with spectra, add all possibilitiess from monopeptide/AA list and then remove combinations whose mass isn't consistent with the spectra
#    while looper < 6: #the looper adjusts tolerance, increases length of final peptide examined
        print(b)
        b += 1
        duppeps = copy.deepcopy(leaderboard)
        leaderboard = []
        for AA in AAmasslist: # generate extended peptides
#           subcopy = copy.deepcopy(Spectrum)
            for i in range(len(duppeps)):
#            for frag in duppeps[i]:
#                subcopy.remove(frag)
                templist = copy.deepcopy(duppeps[i])
                templist.append(AA)
                leaderboard.append(templist)
#        print(leaderboard)
        leadups = copy.deepcopy(leaderboard)
        if len(leadups[0]) >= monocount:
            looper += 1
        for dup in leadups:
            if sum(dup) == parentmass:
                if leaderpeptides == []:
                    leaderpeptides.append(copy.deepcopy(dup))
#                print(dup)
#                print(sum(dup))
#                print(parentmass)
                #Code can be adjusted to generate a linear peptide by altering scoring algorithms
#                dupscore =  PeptideLinearScoring(dup, Spectrum)
#                lpscore =  PeptideLinearScoring(leaderpeptides[0], Spectrum)   
                dupscore =  PeptideCycloScoring(dup, spectrum)
                lpscore =  PeptideCycloScoring(leaderpeptides[0], spectrum)
                if dupscore > lpscore:
                    leaderpeptides = []
                    leaderpeptides.append(copy.deepcopy(dup))
                elif dupscore == lpscore:
                    leaderpeptides.append(copy.deepcopy(dup))
            elif sum(dup) > parentmass: #this will result in the leader board being eventually empty.
                    leaderboard.remove(dup)
#        print(leaderpeptides)
    
        leaderboard = TrimPeptideLeaderboard(leaderboard, spectrum, N) # Trim list.  Keep values of top N scores
#        print(leaderboard)
#        print(looper)
#    print(leaderpeptides)
#    outputlist = []
#    for lead in leaderpeptides:
#        outputlist.append("-".join(list(map(str, lead))))
#    print(len(outputlist))    
#    return ' '.join(outputlist)
    return leaderpeptides

def ConvertPeptideMassToAA(listofpeptidelists):
    """Inputslist of peptide list of list where each sublist is a list of interger
    masses representing a peptide. 
    Outputs a list of peptides using one letter aminoacid code
    of corresponded peptides in AA code. Nonstandard or unknown amino acids 
    will be shown as a number representing its integer mass enclosed in '()'.
    """
    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: '(I/K)', 114: 'N', 115: 'D', 128: '(K/Q)', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'}
    newpeptides = []
    for lst in listofpeptidelists:
        templist = []
        for mass in lst:
            if mass in MasstoAAdict:
                templist.append(MasstoAAdict[mass])
            else:
                templist.append('(' + str(mass) + ')')
        temppep = ''.join(templist)
        newpeptides.append(temppep)
    return newpeptides


#Spectrum_in = '57 57 71 99 129 137 170 186 194 208 228 265 285 299 307 323 356 364 394 422 493'    
#M_in = 20
#N_in = 60


#Spectrum_in = '328 887 229 540 655 128 584 128 688 360 1143 889 832 532 129 483 1187 872 1013 1129 815 912 370 1116 412 372 559 584 418 172 584 916 1116 1059 1187 660 698 461 115 200 313 603 128 1002 1116 1015 428 469 1044 242 1115 647 1116 332 71 186 57 589 256 1001 1244 1015 556 712 114 532 185 229 315 1173 57 816 1017 303 456 784 826 1072 475 103 788 788 300 431 759 557 1145 460 660 232 101 229 546 227 889 485 227 769 1015 1141 355 641 712 357 813 597 355 874 231 1012 775 685 243 884 931 929 128 357 456 99 1130 660 687 1017 944 941 704 761 783 1058 429 0 887 988'
#
#M_in = 17
#N_in = 359

#Spectrum_in = '0 97 99 113 114 115 128 128 147 147 163 186 227 241 242 244 244 256 260 261 262 283 291 309 330 333 340 347 385 388 389 390 390 405 435 447 485 487 503 504 518 544 552 575 577 584 599 608 631 632 650 651 653 672 690 691 717 738 745 770 779 804 818 819 827 835 837 875 892 892 917 932 932 933 934 965 982 989 1039 1060 1062 1078 1080 1081 1095 1136 1159 1175 1175 1194 1194 1208 1209 1223 1322'
#
#M_in = 20
#N_in = 1000
#
#   
#Spectrum_in = list(map(int, Spectrum_in.split(" ")))  
#
#petideseq = CyclopeptideSequencing(Spectrum_in, M_in, N_in) 
#print(petideseq)
#print(ConvertPeptideMassToAA(petideseq))


"""CHALLENGE: Tyrocidine B1 is just one of many known NRPs produced by Bacillus 
brevis. A single bacterial species may produce dozens of different antibiotics, 
and even after 70 years of research, there are likely undiscovered antibiotics 
produced by Bacillus brevis. Try to sequence the tyrocidine corresponding to 
the real experimental spectrum below. Since the fragmentation technology used 
for generating the spectrum tends to produce ions with charge +1, you can 
safely assume that all charges are +1. Return the peptide as a collection of 
space-separated integer masses."""

def ProtonMassSpectrumToIntegerSpectrum1(spectrum):
    """Inputs a spectrum (as a list of floats) where ions are assumed to have 
    a +1 charge and with a mass error of 0.3 Da.  
    Outputs an integer mass spectrum."""
    
    oneless = np.array(spectrum)
    oneless = oneless - 1 #remove +1 charge
#    print(oneless)
    # 
    rounded = [] 
    for mass in oneless: #resolve integermasses from uncharged spectrum:use three numbers, mass, mass +0.3, mass -0.3
        if mass - int(mass) == 0.5: #if num is 0.5 from an int use two ints: rounded up and down
            rounded.append(int(mass)+1)
            rounded.append(int(mass))
        else: #generate 3 ints, take the number repeated as the mass
            temp = [round(mass - 0.3), round(mass), round(mass + 0.3)]
            curr = []
            for num in temp:
                if len(curr) == 0:
                    curr.append(int(num))
                elif curr[0] == int(num):
                     top = curr[0]
                else:
                    curr[0] = int(num)
            rounded.append(top)
    rounded.sort()
    return rounded
    
def ProtonMassSpectrumToIntegerSpectrum2(spectrum):
    """Inputs a spectrum (as a list of floats) where ions are assumed to have 
    a +1 charge and with a mass error of 0.3 Da.  
    Outputs an integer mass spectrum."""
    
    oneless = np.array(spectrum)
    oneless = oneless - 1 #remove +1 charge
    rounded = []
    for mass in oneless:#resolve integermasses from uncharged spectrum:use three numbers, mass, mass +0.3, mass -0.3
        if mass - int(mass) == 0.5: #if num is 0.5 from an int use two ints: rounded up and down
            rounded.append(int(mass)+1)
            rounded.append(int(mass))
        else: #generate 3 ints, take the two ints generated
            temp = [round(mass - 0.3), round(mass), round(mass + 0.3)]
            temp = list(set(temp))
            for num in temp:
                rounded.append(int(num))
    rounded.sort()
    return rounded



            
def ProtonMassSpecCyclopeptideSequencing(massspectrum, M, N):
        spectrum = ProtonMassSpectrumToIntegerSpectrum1(massspectrum)
        sequences = CyclopeptideSequencing(spectrum, M, N)
        return sequences
    

massspec_in = '371.5 375.4 390.4 392.2 409.0 420.2 427.2 443.3 446.4 461.3 471.4 477.4 491.3 505.3 506.4 519.2 536.1 546.5 553.3 562.3 588.2 600.3 616.2 617.4 618.3 633.4 634.4 636.2 651.5 652.4 702.5 703.4 712.5 718.3 721.0 730.3 749.4 762.6 763.4 764.4 779.6 780.4 781.4 782.4 797.3 862.4 876.4 877.4 878.6 879.4 893.4 894.4 895.4 896.5 927.4 944.4 975.5 976.5 977.4 979.4 1005.5 1007.5 1022.5 1023.7 1024.5 1039.5 1040.3 1042.5 1043.4 1057.5 1119.6 1120.6 1137.6 1138.6 1139.5 1156.5 1157.6 1168.6 1171.6 1185.4 1220.6 1222.5 1223.6 1239.6 1240.6 1250.5 1256.5 1266.5 1267.5 1268.6'
massspec_in = list(map(float, massspec_in.split(" ")))  

M_in = 20

N_in = 10000
#print(ProtonMassSpectrumToIntegerSpectrum1(massspec_in))
#print(ProtonMassSpectrumToIntegerSpectrum2(massspec_in))

pepseq = ProtonMassSpecCyclopeptideSequencing(massspec_in, M_in, N_in)
print(pepseq)
print(ConvertPeptideMassToAA(pepseq))
#
#""" using proton mass 2 M20, N1000 -> 6 answers
#147-112-130-164-98-113-131-146-145-82 146-113-130-164-98-113-131-146-145-82 130-114-130-131-131-146-96-129-164-97 114-130-131-131-146-96-129-164-97-130 114-129-164-98-113-130-147-145-97-131 114-129-164-98-113-130-128-164-97-131"""


#using ProtonMassSpectrumToIntegerSpectrum1
#[[115, 146, 130, 113, 129, 163, 82, 163, 112, 115], [97, 164, 128, 116, 130, 113, 128, 164, 99, 129], [164, 98, 128, 145, 116, 129, 163, 82, 113, 130]]
#['D(146)(130)(I/K)EY(82)Y(112)D', 'P(164)(K/Q)(116)(130)(I/K)(K/Q)(164)VE', '(164)(98)(K/Q)(145)(116)EY(82)(I/K)(130)']


#using ProtonMassSpectrumToIntegerSpectrum2
#[[147, 112, 130, 164, 98, 113, 131, 146, 145, 82], [146, 113, 130, 164, 98, 113, 131, 146, 145, 82], [130, 114, 130, 131, 131, 146, 96, 129, 164, 97], [114, 130, 131, 131, 146, 96, 129, 164, 97, 130], [114, 129, 164, 98, 113, 130, 147, 145, 97, 131], [114, 129, 164, 98, 113, 130, 128, 164, 97, 131]]
#['F(112)(130)(164)(98)(I/K)M(146)(145)(82)', '(146)(I/K)(130)(164)(98)(I/K)M(146)(145)(82)', '(130)N(130)MM(146)(96)E(164)P', 'N(130)MM(146)(96)E(164)P(130)', 'NE(164)(98)(I/K)(130)F(145)PM', 'NE(164)(98)(I/K)(130)(K/Q)(164)PM']
#

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

#def CalcAAFragMassDict(frag):
#    """inputs an amino acid fragment and outputs its integer mass
#    It uses a combination of a stored dictionary and a calculation"""
#    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
#    mass = 0
#    with open("PeptideMassDict.txt", "r+") as textfile:
#        PeptideMassDict = textfile.read().split("\n")
#        if frag in PeptideMassDict:
#            return PeptideMassDict[frag]
#        else:
#            for AA in frag:
#                mass += AAtoMassdict[AA]
#            PeptideMassDict[frag] = mass
#            textfile.write(PeptideMassDict)
#            return mass

#def CyclopeptideSequencing1(Spectrum):
#    """Inputs a Mass spectrum as list of integer masses of fragments.  
#    Outputs a cyclic peptide consistent with the spectrum. 
#    Note: Due to duplicated masses I represents both I and L and K 
#    represents both K and Q in AAs list"""
#    AAs = 'GASPVTCINDKEMHFRYW'
#    peptides = ['']
#    foundmasses = []
##    remainingmasses = copy.deepcopy(Spectrum)
#    for AA in AAs:
#        peptides.append(AA)
#    while foundmasses.sort() != Spectrum: 
#        for peptide in peptides:
#            peptidemass = CalcAAFragMass(peptide)
#            if peptidemass in Spectrum:  #adds mass to masslist if found, removes peptide if no match in spectra
#                foundmasses.append(peptidemass)
##                remainingmasses.remove(peptidemass)
#            else:
#                peptides.remove(peptide)
#            for pep in peptides:
#                if pep != '':
#                    for AA in AAs:
#                        peptides.append(pep+AA)
#                        peptides.append(AA+pep)
##                print(peptides)
 
                
#Spectrum_in = '0 113 128 186 241 299 314 427'
#Spectrum_in =  Spectrum_in.split(" ")
#
#print(CyclopeptideSequencing1(Spectrum_in))        

#    while max(peptidemasses) != max(Spectrum):
#        for ma in peptidemasses:
#            for AAmass in AAmasses:
#                m = ma + AAmass
#                if m in Spectrum and ma != 0:    
#                    peptidemasses.append(m)
#                    peptidemstr.append(str(ma)+"-" + str(AAmass))
#                    peptidemstr.append(str(AAmass)+"-" + str(ma))
#                    if AAmass in peptidemassdict:
#                        for y in range(len(peptidemassdict[AAmass])):
#                            if m not in peptidemassdict:
#                                peptidemassdict[m] = [str(ma)+"-"+ peptidemassdict[AAmass][y], peptidemassdict[AAmass][y] +"-" + str(ma)]
#                            else:
#                                peptidemassdict.setdefault(m, []).append(str(ma)+"-"+ peptidemassdict[AAmass][y])
#                                peptidemassdict.setdefault(m, []).append(peptidemassdict[AAmass][y] +"-" + str(ma))
#                                #peptidemassdict[m].append(str(ma)+"-"+ peptidemassdict[AAmass][y])
#                                #peptidemassdict[m].append(peptidemassdict[AAmass][y] +"-" + str(ma))
#                    else:    
#                        peptidemassdict[m] = [str(ma)+"-" + str(AAmass), str(AAmass)+"-" + str(ma)]
#                    
##                    peptidemasses =  peptidemasses.sort()
##                    peptidemstr = peptidemstr.sort(key=int)
#            print("peptidemasses")        
#            print(peptidemasses)
#            print("peptidemassdict")
#            print(peptidemstr)
#            raise SystemExit(0)     
#                        
       
#def CyclopeptideMassFrags(Spectrum):
#    """Inputs a Mass spectrum as list of integer masses of fragments.  
#    Outputs a cyclic peptide as masses of fragments """
##    AAs = 'GASPVTCINDKEMHFRYW'
#    AAmasses = [0, 57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
##    intactmass = max(Spectrum)
#    peptidemstr = []
#    peptidemasses = []
#    peptidemassdict = {}
##    foundmasses = []
#    for mass in AAmasses:
#        if mass in Spectrum:
#            peptidemasses.append(mass)
#            peptidemassdict[mass] = [str(mass)]
#            peptidemstr.append(str(mass))
#    print("peptidemasses")        
#    print(peptidemasses)
#    print("peptidemstr")
#    print(peptidemstr) 
#    print("peptidemassdict")
#    print(peptidemassdict)
#    while max(peptidemasses) != max(Spectrum):
#        for ma in peptidemasses:
#            for AAmass in AAmasses:
#                m = ma + AAmass
#                if m in Spectrum and ma != 0:    
#                    peptidemasses.append(m)
#                    peptidemstr.append(str(ma)+"-" + str(AAmass))
#                    peptidemstr.append(str(AAmass)+"-" + str(ma))
#                    if AAmass in peptidemassdict:
#                        for y in range(len(peptidemassdict[AAmass])):
#                            if m not in peptidemassdict:
#                                peptidemassdict[m] = [str(ma)+"-"+ peptidemassdict[AAmass][y], peptidemassdict[AAmass][y] +"-" + str(ma)]
#                            else:
#                                peptidemassdict.setdefault(m, []).append(str(ma)+"-"+ peptidemassdict[AAmass][y])
#                                peptidemassdict.setdefault(m, []).append(peptidemassdict[AAmass][y] +"-" + str(ma))
#                                #peptidemassdict[m].append(str(ma)+"-"+ peptidemassdict[AAmass][y])
#                                #peptidemassdict[m].append(peptidemassdict[AAmass][y] +"-" + str(ma))
#                    else:    
#                        peptidemassdict[m] = [str(ma)+"-" + str(AAmass), str(AAmass)+"-" + str(ma)]
#                    
##                    peptidemasses =  peptidemasses.sort()
##                    peptidemstr = peptidemstr.sort(key=int)
#            print("peptidemasses")        
#            print(peptidemasses)
#            print("peptidemassdict")
#            print(peptidemstr)
#            raise SystemExit(0) 
       
#def GenerateMassAAFragdictionary(k):
#    """ Generates a dictionary of all possible permuations of AA up to length k with their
#    integer masses. Note: Due to duplicated I represents both I and L, K 
#    represents both K and Q"""
#    AAs = 'GASPVTCINDKEMHFRYW'
#    permslist = []
#    MassAAFragdictionary = {}
#    for AA in AAs:
#        permslist.append(AA)
#    for i in range(1,k+1): #i is size of fragment
#        perms = list(itertools.permutations(AAs,i))
#        for item in perms:
#            permslist.append(''.join(list(item)))
#    for frag in permslist:
#        MassAAFragdictionary[frag] = CalcAAFragMass(frag)
#    
#    return str(MassAAFragdictionary)   
#      
#with open("PeptideMassDict.txt", "w+") as textfile:
#  textfile.write(GenerateMassAAFragdictionary(4))  

#def CyclopeptideMassFrags(Spectrum):
#    """Inputs a Mass spectrum as list of integer masses of fragments.  
#    Outputs a cyclic peptide as masses of fragments """
##    AAs = 'GASPVTCINDKEMHFRYW'
#    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: 'I', 114: 'N', 115: 'D', 128: 'K', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'} 
#    AAmasses = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    intactmass = max(Spectrum)
##    peptidemstr = []
#    peptidemasses = []
#    peptidemassdict = {}
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)   
#    for mass in AAmasses:
#        if mass in Spectrum:
#            peptidemasses.append(mass)
#            peptidemassdict[mass] = MasstoAAdict[mass]
##            peptidemstr.append(str(mass))
#    L = len(peptidemasses)
#    for i in range(L,len(Spectrum)):
#        print(i)
#        specmass = Spectrum[i]
#        for AAmass in peptidemasses:
#            submass = specmass - AAmass
#            if submass in Spectrum:                    
#                peptidemassdict[specmass] = MasstoAAdict[submass] + MasstoAAdict[AAmass]
#                MasstoAAdict[specmass] = MasstoAAdict[submass] + MasstoAAdict[AAmass]
#                
##        print("peptidemasses")        
##        print(peptidemasses)
##        print("peptidemassdict")
##        print(peptidemassdict)
##        print(peptidemassdict)            
##        peptidemassdict[specmass] = set(peptidemassdict[specmass])
##        peptidemassdict[specmass] = list(peptidemassdict[specmass])
##        print(peptidemassdict)
##    print("LAST") 
##    print(peptidemassdict)
#    completelist =  peptidemassdict[intactmass]
#    print(completelist)
#    possibilities = [completelist]
#    first = completelist[:1]
#    firstreverse = first[::-1]
#    second = completelist[1]
#    third = completelist[2:]
#    thirdreverse = third[::-1]
#    inverse = thirdreverse + second + firstreverse
#    possibilities.append(inverse)
#    print(possibilities)
##    for j in range(1,len(completelist)):
#        
##    listdict = {}
##    for j in range(len(completelist)):
##        if isinstance(completelist[j], int):
##            listdict[j] = 1
##        else:    
##            listdict[j] = len(completelist[j])
##    print(listdict)   
##    peptidemassfrags = []
###    for x in range(len(completelist)):
###        if listdict[x] ==
#        
#    return peptidemassdict[intactmass]   


#def CyclopeptideSequencing(Spectrum):
#    peptides = []
##    peptideseq = []
##    peptidemasses = []
#    AAs = []
##    AAmasses = []
#    parentmass = max(Spectrum)
##    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
##    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: 'I', 114: 'N', 115: 'D', 128: 'K', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'} 
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)
#    for mass in Spectrum:
#        if mass in AAmasslist:
#            if len(str(mass)) < 3:
#                peptides.append('0'+str(mass))
#                AAs.append('0'+str(mass))
#            else:
#                peptides.append(str(mass))
#                AAs.append(str(mass))
##    print("peptides")
##    print(peptides) 
##    print("AAs")
##    print(AAs)            
#    i=1
#    looper = 0
#    while looper == 0:
#        duppeps = copy.deepcopy(peptides)
##        print(duppeps)
#        print(i)
#        i += 1
#        for pep in duppeps:
##            print(pep)
#            if len(pep) > 3:
#                pepmass = 0
##                print("helll")
#                for t in range(0,len(pep),3):
#                    pepmass += int(pep[t:t+3])
##                    print(pepmass)           
#            else:
#                pepmass = int(pep)  
##                print("else")
#            for AA in AAs:
##                print(pepmass)
##                print(AA)
#                if pepmass + int(AA) in Spectrum:
##                    print(pep+AA)
#                    peptides.append(pep+AA)
#                    peptides.append(AA+ pep)
#                    L = len(pep+AA)
##INSTEAD OF USING STRINGS, USE NESTED LISTS IN PEPTIDES, THEN GET RID OF SMALLEST LISTS
## LAST LOOP WILL BE A LOOP OF "-".JOIN()  MUCH FASTER.                    
##                    print(L)
#                if pepmass == parentmass:
##                    print(pepmass)
##                    print(parentmass)
#                    looper += 1
##        print(peptides)     
#        dupdup =  copy.deepcopy(peptides)           
#        for peptide in dupdup:
#            if len(peptide) < L:
#                peptides.remove(peptide)
#             
#        peptides = set(peptides)
#        peptides = list(peptides)
##        print("peptides")
##        print(peptidelist)
#    outputlist = []
#    for p in peptides:
#        temp = ""
#        for t in range(0,len(p),3):
#            if p[t:t+3][0] == '0':
#                temp += p[t+1:t+3] + "-"
#            else:
#                temp += p[t:t+3] + "-"
##            print(temp)
#        outputlist.append(temp[:-1])
#    return " ".join(outputlist)
             


        
#def pathchecker(spectrum, path1, path2):
#   # Takes two paths, and checks they are connected by a single AA overlap.
#   # The paths are represented as integers in lists.
#   # Returns the path if they are connected, or an empty list if not.
#   # path1 can be any length, path2 should be a dipeptide.
#   # Also makes sure that any amino acids are present in the spectrum the
#   # correct number of times.
#   if path1[-1] != path2[0]:
#       return []
#   sublist = path1[:-1]
#   sublist = sublist + path2
#   spec = copy.deepcopy(spectrum)
#   if sum(sublist) not in spec:
#       return []
#   if sum(sublist) in spectrum:
#       for x in sublist:
#           if x in spec:
#               spec.remove(x)
#           else:
#               return []
#       return sublist
        
        
#def pathchecker(Spectrum, path1, path2):
#   # Takes two paths, and checks they are connected by a single AA overlap.
#   # The paths are represented as integers in lists.
#   # Returns True if they are connected, False if they are not.
#   if path1[-1] != path2[0]:
#       return []
#   sublist = path1[:-1]
#   sublist = sublist + path2 
#   if sum(sublist) in Spectrum:
#       return sublist
#   if sum(sublist) not in Spectrum:
#       return []

#def CPeptideSequence(Spectrum):
#    peptides = []
#    dipeptides = []
#    AAs = []
#    intactpeptide = max(Spectrum)
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)
#    specmasslist = copy.deepcopy(Spectrum)  
#    specmasslist.remove(intactpeptide)
#    for mass in AAmasslist:
#        if mass in Spectrum:
#            peptides.append(mass)
#            AAs.append(mass)
#    looper = 0
#    b= 0   
#    # Generates a list of all dipeptides present in spectrum.
#    for pep in peptides:
#        subcopy = copy.deepcopy(AAs)
#        subcopy.remove(pep)
#        for AA in AAs:
#            if AA in subcopy and pep + AA in Spectrum:
#                dipeptides.append([pep, AA])
#    peptides = copy.deepcopy(dipeptides) 
#
#    while looper == 0:
#        print(b)
#        b += 1
#        paths = []
#        for peptide in peptides:
#            subcopy = copy.deepcopy(AAs)
#            for f in peptide:
#                subcopy.remove(f)
#            for frag in dipeptides:
#                if frag[1] in subcopy:
#                    fragpath = pathchecker(Spectrum, peptide, frag)
#                    if fragpath != []:
#                        paths.append(fragpath)
#                    if sum(fragpath) == intactpeptide:
#                        looper = 1
#        peptides = copy.deepcopy(paths)
##    print(paths)
#    outputlist = []
#    for path in paths:
#        outputlist.append("-".join(list(map(str, path))))
#    return " ".join(outputlist)     

#def CyclopeptideMassFrags(Spectrum):
#    """Inputs a Mass spectrum as list of integer masses of fragments.  
#    Outputs a cyclic peptide as masses of fragments """
##    AAs = 'GASPVTCINDKEMHFRYW'
#    AAmasses = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    intactmass = max(Spectrum)
##    peptidemstr = []
#    peptidemasses = []
#    peptidemassdict = {}
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)   
#    for mass in AAmasses:
#        if mass in Spectrum:
#            peptidemasses.append(mass)
#            peptidemassdict[mass] = [str(mass)]
##            peptidemstr.append(str(mass))
#    L = len(peptidemasses)
#    try:
#        for i in range(L,len(Spectrum)):
#            print(i)
#            specmass = Spectrum[i]
##            print(specmass)
#            for AAmass in peptidemasses:
#                submass = specmass - AAmass
#                if submass in Spectrum:
#                    if submass in peptidemassdict:
#                        for m in peptidemassdict[submass]:
#                            peptidemassdict.setdefault(specmass, []).append(m+"-"+ peptidemassdict[AAmass][0])
#                            peptidemassdict.setdefault(specmass, []).append(peptidemassdict[AAmass][0]+"-"+ m)
##                            peptidemassdict[specmass] = [peptidemassdict[submass][m], peptidemassdict[AAmass]]
#                    else:
#                        print("Error: " + str(submass) +" submass not in peptide dictionary")
#    except Exception as ex:
#        template = "An exception of type {0} occurred. Arguments:\n{1!r}"
#        message = template.format(type(ex).__name__, ex.args)
#        print(message)
#        
#
##        peptidemassdict[specmass] = set(peptidemassdict[specmass])
##        peptidemassdict[specmass] = list(peptidemassdict[specmass])
#
##        print("peptidemasses")        
##        print(peptidemasses)
##        print("peptidemassdict")
##        print(peptidemassdict)
##    print("peptidemassdict")
##    print(peptidemassdict)
#            
#    return peptidemassdict[intactmass]  
    

#def CyclopeptideSequencing(Spectrum):
#    peptides = []
#    peptideseq = []
#    peptidemasses = []
#    AAs = []
#    AAmasses = []
#    parentmass = max(Spectrum)
#    AAtoMassdict = {'': 0, 'A': 71, 'C': 103, 'D': 115, 'E': 129, 'F': 147, 'G': 57, 'H': 137, 'I': 113, 'K': 128, 'L': 113, 'M': 131, 'N': 114, 'P': 97, 'Q': 128, 'R': 156, 'S': 87, 'T': 101, 'V': 99, 'W': 186, 'Y': 163}
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    MasstoAAdict = {0: '', 57: 'G', 71: 'A', 87: 'S', 97: 'P', 99: 'V', 101: 'T', 103: 'C', 113: 'I', 114: 'N', 115: 'D', 128: 'K', 129: 'E', 131: 'M', 137: 'H', 147: 'F', 156: 'R', 163: 'Y', 186: 'W'} 
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)
#    for mass in AAmasslist:
#        if mass in Spectrum:
#            peptides.append(MasstoAAdict[mass])
#            peptidemasses.append(str(mass))
#            AAmasses.append(mass)
#            AAs.append(MasstoAAdict[mass])
##    print("peptides")
##    print(peptides) 
##    print("AAs")
##    print(AAs)            
##    L = len(AAs)
#    i=1
#    while peptideseq == []:
#        duppeps = copy.deepcopy(peptides)
#        print(i)
#        i += 1
#        for pep in duppeps:     
#            for AA in AAs:
#                peptides.append(pep+AA)
#                peptides.append(AA+pep)
#            peptides = set(peptides)
#            peptides = list(peptideseq)
##        print("peptides")
##        print(peptides)
#        for p in peptides :  
##            print(p)
#            if p in AAtoMassdict:
#                fragmass = AAtoMassdict[p]
#            else:
#                fragmass = CalcAAFragMass(p)
#                AAtoMassdict[p] = fragmass
#            if fragmass not in Spectrum:
#                peptides.remove(p)
#            if fragmass == parentmass:
#                peptideseq.append(p)
##    peptideseq = set(peptideseq)
##    peptideseq = list(peptideseq)
#    return peptideseq



#def SequenceCycloPeptide(Spectrum):
#    peptides = []
#    AAs = []
#    intactpeptide = max(Spectrum)
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    if 0 in Spectrum: #remove 0 from spectrum
#        Spectrum.remove(0)
#    for mass in AAmasslist:
#        if mass in Spectrum:
#            if len(str(mass)) < 3:
#                peptides.append([str(mass)])
#                AAs.append(str(mass))
#            else:
#                peptides.append([str(mass)])
#                AAs.append(str(mass))
#                
#    b=1
#    looper = 0
#    while looper == 0:
##    while i < 3:
#        duppeps = copy.deepcopy(peptides)
##        print(duppeps)
#        print(b)
#        b += 1
#        for AA in AAs:
#
#            for i in range(len(duppeps)):
#                #        for peplist in duppeps:
#                #            print(pep)
#                pepmass = 0
#            
#                for pep in duppeps[i]:
#                    pepmass += int(pep)
#                    fragmass = pepmass + int(AA)
#                if fragmass in Spectrum:
##                    print(pep+AA)
#                    reverse = duppeps[i][::-1]
#                    reverse.insert(0,AA)
#                    peptides[i].append(AA)
#                    peptides.append(reverse)
##NEED TO FIND A WAY SO THAT SMALLEST ONE DOESN'T ALWAYS GO FIRST NEED 186-128-113
#                    L = len(peptides[i])                    
##                    print(peptides[i])
#            print(peptides) 
#            num = len(peptides)
#            intactcount = 0
#            for peptide in peptides:
#                sumpeps = sum(list(map(int, peptide)))    
#                if sumpeps == intactpeptide:
#                    intactcount += 1
#            if intactcount == num:
#                looper += 1              
# 
#        dupdup =  copy.deepcopy(peptides)           
#          
#        for peptidelist in dupdup:
#            if len(peptidelist) < L:
#                peptides.remove(peptidelist)
#        print(peptides) 
#        for peptidelist in dupdup:
#            peptides.append(peptidelist[::-1])
#        dupdup =  copy.deepcopy(peptides) 
#        outputlist = []
#        for peppep in peptides:
#            outputlist.append("-".join(peppep))
#        outputlist = set(outputlist)
#        outputlist = list(outputlist)
#        return " ".join(outputlist)






                
#    b=1
#    looper = 0
#    while looper == 0:
##    while i < 3:
#        duppeps = copy.deepcopy(peptides)
##        print(duppeps)
#        print(b)
#        b += 1
#        for i in range(len(duppeps)):
##        for peplist in duppeps:
##            print(pep)
#            pepmass = 0
#            
#            for pep in duppeps[i]:
#                pepmass += int(pep)
#            for AA in AAs:
##                print(pepmass)
##                print(AA)
#                fragmass = pepmass + int(AA)
#                if fragmass in Spectrum:
##                    print(pep+AA)
#                    reverse = duppeps[i][::-1]
#                    reverse.insert(0,AA)
#                    peptides[i].append(AA)
#                    peptides.append(reverse)
##NEED TO FIND A WAY SO THAT SMALLEST ONE DOESN'T ALWAYS GO FIRST NEED 186-128-113
#                    L = len(peptides[i])                    
##                    print(peptides[i])
#                sumpeps = sum(list(map(int, peptides[i])))    
#                if sumpeps == intactpeptide:
##                    print(pepmass)
##                    print(parentmass)
#                    looper += 1  
#        print(peptides)  
#        dupdup =  copy.deepcopy(peptides)           
##        for peptidelist in dupdup:
##            peptides.append(peptidelist[::-1])
##        dupdup =  copy.deepcopy(peptides)           
#        for peptidelist in dupdup:
#            if len(peptidelist) < L:
#                peptides.remove(peptidelist)
#        print(peptides) 
##        outputlist = []
##        for peppep in peptides:
##            outputlist.append("-".join(peppep))
##        return " ".join(outputlist)
                    
                

#def CyclopeptideSequencing1(Spectrum):  
#    peptides = []
#    AAs = []
#    parentmass = max(Spectrum)
#    AAmasslist = [57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129, 131, 137, 147, 156, 163, 186]
#    #remove 0 and parent mass from spectrum
#    Spectrum.remove(0)
#    Spectrum.remove(parentmass)
#    #Build monopeptide list and start peptides list
#    for mass in AAmasslist:
#        if mass in Spectrum:
#                peptides.append([mass])
#                AAs.append(mass)
#    #generate strings consistent with spectra, add all possibilitiess from 
#    #monopeptide/AA list and then remove combinations whose mass isn't 
#    #consistent with the spectra
#    b=0
#    looper = 0
#    duppeps = copy.deepcopy(peptides)
#    peptides = []
##    while b < 1:
#    while looper == 0:
#        print(b)
#        b += 1
#        if peptides != []:
#            duppeps = copy.deepcopy(peptides)
#        for AA in AAs:
#            subcopy = copy.deepcopy(AAs)
#            for i in range(len(duppeps)):
##                reverse = duppeps[i][::-1]
##                reverse.insert(0,AA)
##                duppeps[i].append(AA)
#                for frag in duppeps[i]:
#                    subcopy.remove(frag)
#                if AA in subcopy:
#                    templist = copy.deepcopy(duppeps[i])
#                    templist.append(AA)
#                    peptides.append(templist)
#                subcopy = copy.deepcopy(AAs)
##                peptides.append(reverse)
##        peptides = copy.deepcopy(duppeps)
##            print(peptides)        
#        peppeps = copy.deepcopy(peptides)        
#        for j in range(len(peppeps)):
#            sumpeps = sum(peppeps[j]) 
#            if sumpeps not in Spectrum and sumpeps != parentmass:
#                peptides.remove(peppeps[j])
#            if sumpeps == parentmass:
#                looper += 1
#                L = len(peppeps[j])
#                
#    print(peptides) 
#    peptidesolve = []
#    for i in range(2, L):
#        for j in range(len(peptides)):
#            for k in range(len(peptides)):
#                if len(peptides[j]) == len(peptides[k]) == i:
#                    if peptides[j][-1] == peptides[k][0]:
#                        plist = peptides[j][:]
#                        plist.extend(peptides[k][1:])
#                        peptidesolve.append(plist)
#    print(peptidesolve)
#    peptidetemp = copy.deepcopy(peptidesolve)  
#    for pep in peptidetemp:
#            if pep in peptidesolve and len(pep) < L:
#                peptidesolve.remove(pep)
#            elif pep in peptidesolve and pep not in peptides:
#                peptidesolve.remove(pep) 
#    print(peptidesolve)        
#    outputlist = []
#    for p in peptidesolve:
#        outputlist.append("-".join(list(map(str, p))))
#    outputlist = set(outputlist)
#    outputlist = list(outputlist)
#    return " ".join(outputlist) 
##            sumpeps = sum(list(map(int, peppep[j])))
        